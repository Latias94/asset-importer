//! Internal pointer utilities.
//!
//! Assimp types generated by bindgen are not `Send`/`Sync` (they contain raw `*mut` fields),
//! and raw pointers themselves are not `Send`/`Sync` in Rust. At the same time, this crate's
//! safe API only provides *read-only* access to Assimp-owned scene data after import.
//!
//! To keep the public API ergonomic (usable with `Arc` / multithreading) while keeping the
//! unsafety centralized, we wrap all Assimp pointers in `SharedPtr`.

/// A non-null raw pointer wrapper with centralized `Send + Sync` semantics.
///
/// # Safety contract
/// - `SharedPtr<T>` must only point to valid memory for the duration it is used.
/// - The referenced memory must not be mutated through safe Rust while shared across threads.
/// - In this crate, `SharedPtr` is used for Assimp-owned, post-import scene data which is treated
///   as immutable by the safe API.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub(crate) struct SharedPtr<T>(*const T);

/// Marker trait: types that are safe to share across threads as *read-only* when wrapped
/// by `SharedPtr`.
///
/// # Safety
/// Implementors must guarantee that values reachable through pointers of this type will only be
/// accessed immutably through this crate's safe API when shared across threads. If the underlying
/// memory can be mutated concurrently (or exposed for mutation elsewhere), marking it as a shared
/// target can violate Rust aliasing rules and cause undefined behavior.
pub(crate) unsafe trait SharedPtrTarget {}

// Scene-backed Assimp structs we expose through the safe API.
unsafe impl SharedPtrTarget for crate::sys::aiScene {}
unsafe impl SharedPtrTarget for crate::sys::aiNode {}
unsafe impl SharedPtrTarget for crate::sys::aiMesh {}
unsafe impl SharedPtrTarget for crate::sys::aiMaterial {}
unsafe impl SharedPtrTarget for crate::sys::aiMaterialProperty {}
unsafe impl SharedPtrTarget for crate::sys::aiAnimation {}
unsafe impl SharedPtrTarget for crate::sys::aiNodeAnim {}
unsafe impl SharedPtrTarget for crate::sys::aiMeshAnim {}
unsafe impl SharedPtrTarget for crate::sys::aiMeshMorphAnim {}
unsafe impl SharedPtrTarget for crate::sys::aiMeshMorphKey {}
unsafe impl SharedPtrTarget for crate::sys::aiCamera {}
unsafe impl SharedPtrTarget for crate::sys::aiLight {}
unsafe impl SharedPtrTarget for crate::sys::aiTexture {}
unsafe impl SharedPtrTarget for crate::sys::aiAnimMesh {}
unsafe impl SharedPtrTarget for crate::sys::aiBone {}

// Export-side blob chain (safe to share as read-only; ownership is handled elsewhere).
unsafe impl SharedPtrTarget for crate::sys::aiExportDataBlob {}

// Crate-owned raw view types (backed by Assimp scene memory).
unsafe impl SharedPtrTarget for crate::raw::AiFace {}

// Pointer arrays in Assimp use `T**` layouts; treat the pointer elements as shareable only
// when the pointee type itself is a valid shared target.
unsafe impl<T: SharedPtrTarget> SharedPtrTarget for *const T {}

impl<T> SharedPtr<T> {
    /// Creates a new `SharedPtr` if `ptr` is non-null.
    pub(crate) fn new(ptr: *const T) -> Option<Self> {
        if ptr.is_null() {
            return None;
        }

        let align = std::mem::align_of::<T>();
        if align > 1 && (ptr as usize) % align != 0 {
            return None;
        }

        Some(Self(ptr))
    }

    /// Creates a new `SharedPtr` without checking for null.
    ///
    /// # Safety
    /// The caller must ensure `ptr` is non-null.
    pub(crate) unsafe fn new_unchecked(ptr: *const T) -> Self {
        debug_assert!(!ptr.is_null());
        debug_assert!(
            std::mem::align_of::<T>() <= 1 || (ptr as usize) % std::mem::align_of::<T>() == 0
        );
        Self(ptr)
    }

    /// Returns the underlying raw pointer.
    pub(crate) fn as_ptr(&self) -> *const T {
        self.0
    }

    /// Returns a shared reference to the pointed-to value.
    ///
    /// This is safe because `SharedPtr` is only constructed from pointers that are guaranteed
    /// to remain valid for the lifetime of the owning safe wrapper type.
    pub(crate) fn as_ref(&self) -> &T {
        debug_assert!(
            std::mem::align_of::<T>() <= 1 || (self.0 as usize) % std::mem::align_of::<T>() == 0
        );
        // SAFETY: The crate only constructs `SharedPtr` from pointers that remain valid for the
        // lifetime of the owning wrapper, and the safe API treats Assimp scene data as read-only.
        unsafe { &*self.0 }
    }
}

#[cfg(test)]
mod tests {
    use super::SharedPtr;

    #[test]
    fn new_rejects_null_and_unaligned_pointers() {
        assert!(SharedPtr::<u32>::new(std::ptr::null()).is_none());

        let buf = [0u32; 2];
        let unaligned = unsafe { (buf.as_ptr() as *const u8).add(1) } as *const u32;
        assert!(SharedPtr::new(unaligned).is_none());

        assert!(SharedPtr::new(buf.as_ptr()).is_some());
    }
}

// Safety: only allow cross-thread sharing for targets explicitly marked as safe to share
// as read-only through this crate's API.
unsafe impl<T: SharedPtrTarget> Send for SharedPtr<T> {}
unsafe impl<T: SharedPtrTarget> Sync for SharedPtr<T> {}
