//! Internal pointer utilities.
//!
//! Assimp types generated by bindgen are not `Send`/`Sync` (they contain raw `*mut` fields),
//! and raw pointers themselves are not `Send`/`Sync` in Rust. At the same time, this crate's
//! safe API only provides *read-only* access to Assimp-owned scene data after import.
//!
//! To keep the public API ergonomic (usable with `Arc` / multithreading) while keeping the
//! unsafety centralized, we wrap all Assimp pointers in `SharedPtr`.

/// A non-null raw pointer wrapper with centralized `Send + Sync` semantics.
///
/// # Safety contract
/// - `SharedPtr<T>` must only point to valid memory for the duration it is used.
/// - The referenced memory must not be mutated through safe Rust while shared across threads.
/// - In this crate, `SharedPtr` is used for Assimp-owned, post-import scene data which is treated
///   as immutable by the safe API.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub(crate) struct SharedPtr<T>(*const T);

impl<T> SharedPtr<T> {
    /// Creates a new `SharedPtr` if `ptr` is non-null.
    pub(crate) fn new(ptr: *const T) -> Option<Self> {
        if ptr.is_null() { None } else { Some(Self(ptr)) }
    }

    /// Returns the underlying raw pointer.
    pub(crate) fn as_ptr(self) -> *const T {
        self.0
    }
}

// Safety: this is crate-internal and only used for immutable, Assimp-owned scene data.
unsafe impl<T> Send for SharedPtr<T> {}
unsafe impl<T> Sync for SharedPtr<T> {}
