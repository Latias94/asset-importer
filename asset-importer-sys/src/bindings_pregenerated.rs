/* automatically generated by rust-bindgen 0.72.1 */

pub const AI_MATH_PI: f64 = 3.141592653589793;
pub const AI_MATH_TWO_PI: f64 = 6.283185307179586;
pub const AI_MATH_HALF_PI: f64 = 1.5707963267948966;
pub const AI_MATH_PI_F: f64 = 3.1415926538;
pub const AI_MATH_TWO_PI_F: f64 = 6.2831853076;
pub const AI_MATH_HALF_PI_F: f64 = 1.5707963269;
pub const AI_MAXLEN: u32 = 1024;
pub const AI_FALSE: u32 = 0;
pub const AI_TRUE: u32 = 1;
pub const AI_EMBEDDED_TEXNAME_PREFIX: &[u8; 2] = b"*\0";
pub const AI_MAX_FACE_INDICES: u32 = 32767;
pub const AI_MAX_BONE_WEIGHTS: u32 = 2147483647;
pub const AI_MAX_VERTICES: u32 = 2147483647;
pub const AI_MAX_FACES: u32 = 2147483647;
pub const AI_MAX_NUMBER_OF_COLOR_SETS: u32 = 8;
pub const AI_MAX_NUMBER_OF_TEXTURECOORDS: u32 = 8;
pub const AI_DEFAULT_MATERIAL_NAME: &[u8; 16] = b"DefaultMaterial\0";
pub const AI_SCENE_FLAGS_INCOMPLETE: u32 = 1;
pub const AI_SCENE_FLAGS_VALIDATED: u32 = 2;
pub const AI_SCENE_FLAGS_VALIDATION_WARNING: u32 = 4;
pub const AI_SCENE_FLAGS_NON_VERBOSE_FORMAT: u32 = 8;
pub const AI_SCENE_FLAGS_TERRAIN: u32 = 16;
pub const AI_SCENE_FLAGS_ALLOW_SHARED: u32 = 32;
pub type ai_real = f32;
pub type ai_int = ::std::os::raw::c_int;
pub type ai_uint = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiVector2D {
    pub x: ai_real,
    pub y: ai_real,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiVector3D {
    pub x: ai_real,
    pub y: ai_real,
    pub z: ai_real,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiColor4D {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiMatrix3x3 {
    pub a1: ai_real,
    pub a2: ai_real,
    pub a3: ai_real,
    pub b1: ai_real,
    pub b2: ai_real,
    pub b3: ai_real,
    pub c1: ai_real,
    pub c2: ai_real,
    pub c3: ai_real,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiMatrix4x4 {
    pub a1: ai_real,
    pub a2: ai_real,
    pub a3: ai_real,
    pub a4: ai_real,
    pub b1: ai_real,
    pub b2: ai_real,
    pub b3: ai_real,
    pub b4: ai_real,
    pub c1: ai_real,
    pub c2: ai_real,
    pub c3: ai_real,
    pub c4: ai_real,
    pub d1: ai_real,
    pub d2: ai_real,
    pub d3: ai_real,
    pub d4: ai_real,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiQuaternion {
    pub w: ai_real,
    pub x: ai_real,
    pub y: ai_real,
    pub z: ai_real,
}
pub type ai_int32 = i32;
pub type ai_uint32 = u32;
#[doc = " Represents a plane in a three-dimensional, euclidean space"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiPlane {
    #[doc = "! Plane equation"]
    pub a: ai_real,
    #[doc = "! Plane equation"]
    pub b: ai_real,
    #[doc = "! Plane equation"]
    pub c: ai_real,
    #[doc = "! Plane equation"]
    pub d: ai_real,
}
#[doc = " Represents a ray"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiRay {
    #[doc = "! Position and direction of the ray"]
    pub pos: aiVector3D,
    #[doc = "! Position and direction of the ray"]
    pub dir: aiVector3D,
}
#[doc = " Represents a color in Red-Green-Blue space."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiColor3D {
    #[doc = "! Red, green and blue color values"]
    pub r: f32,
    #[doc = "! Red, green and blue color values"]
    pub g: f32,
    #[doc = "! Red, green and blue color values"]
    pub b: f32,
}
#[doc = " @brief Represents an UTF-8 string, zero byte terminated.\n\n  The character set of an aiString is explicitly defined to be UTF-8. This Unicode\n  transformation was chosen in the belief that most strings in 3d files are limited\n  to ASCII, thus the character set needed to be strictly ASCII compatible.\n\n  Most text file loaders provide proper Unicode input file handling, special unicode\n  characters are correctly transcoded to UTF8 and are kept throughout the libraries'\n  import pipeline.\n\n  For most applications, it will be absolutely sufficient to interpret the\n  aiString as ASCII data and work with it as one would work with a plain char*.\n  Windows users in need of proper support for i.e asian characters can use the\n  MultiByteToWideChar(), WideCharToMultiByte() WinAPI functionality to convert the\n  UTF-8 strings to their working character set (i.e. MBCS, WideChar).\n\n  We use this representation instead of std::string to be C-compatible. The\n  (binary) length of such a string is limited to AI_MAXLEN characters (including the\n  the terminating zero)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiString {
    #[doc = " Binary length of the string excluding the terminal 0. This is NOT the\n  logical length of strings containing UTF-8 multi-byte sequences! It's\n  the number of bytes from the beginning of the string to its end."]
    pub length: ai_uint32,
    #[doc = " String buffer. Size limit is AI_MAXLEN"]
    pub data: [::std::os::raw::c_char; 1024usize],
}
impl Default for aiString {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " Standard return type for some library functions.\n Rarely used, and if, mostly in the C API."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiReturn {
    #[doc = " Indicates that a function was successful"]
    aiReturn_SUCCESS = 0,
    #[doc = " Indicates that a function failed"]
    aiReturn_FAILURE = -1,
    #[doc = " Indicates that not enough memory was available\n to perform the requested operation"]
    aiReturn_OUTOFMEMORY = -3,
    #[doc = " @cond never\n  Force 32-bit size enum"]
    _AI_ENFORCE_ENUM_SIZE = 2147483647,
}
#[repr(i32)]
#[doc = " Seek origins (for the virtual file system API).\n  Much cooler than using SEEK_SET, SEEK_CUR or SEEK_END."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiOrigin {
    #[doc = " Beginning of the file"]
    aiOrigin_SET = 0,
    #[doc = " Current position of the file pointer"]
    aiOrigin_CUR = 1,
    #[doc = " End of the file, offsets must be negative"]
    aiOrigin_END = 2,
    #[doc = "  @cond never\n   Force 32-bit size enum"]
    _AI_ORIGIN_ENFORCE_ENUM_SIZE = 2147483647,
}
pub mod aiDefaultLogStream {
    #[doc = " @brief Enumerates predefined log streaming destinations.\n  Logging to these streams can be enabled with a single call to\n   #LogStream::createDefaultStream."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = " Stream the log to a file"]
    pub const aiDefaultLogStream_FILE: Type = 1;
    #[doc = " Stream the log to std::cout"]
    pub const aiDefaultLogStream_STDOUT: Type = 2;
    #[doc = " Stream the log to std::cerr"]
    pub const aiDefaultLogStream_STDERR: Type = 4;
    #[doc = " MSVC only: Stream the log the the debugger\n (this relies on OutputDebugString from the Win32 SDK)"]
    pub const aiDefaultLogStream_DEBUGGER: Type = 8;
    #[doc = " @cond never\n  Force 32-bit size enum"]
    pub const _AI_DLS_ENFORCE_ENUM_SIZE: Type = 2147483647;
}
#[doc = " Stores the memory requirements for different components (e.g. meshes, materials,\n  animations) of an import. All sizes are in bytes.\n  @see Importer::GetMemoryRequirements()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiMemoryInfo {
    #[doc = " Storage allocated for texture data"]
    pub textures: ::std::os::raw::c_uint,
    #[doc = " Storage allocated for material data"]
    pub materials: ::std::os::raw::c_uint,
    #[doc = " Storage allocated for mesh data"]
    pub meshes: ::std::os::raw::c_uint,
    #[doc = " Storage allocated for node data"]
    pub nodes: ::std::os::raw::c_uint,
    #[doc = " Storage allocated for animation data"]
    pub animations: ::std::os::raw::c_uint,
    #[doc = " Storage allocated for camera data"]
    pub cameras: ::std::os::raw::c_uint,
    #[doc = " Storage allocated for light data"]
    pub lights: ::std::os::raw::c_uint,
    #[doc = " Total storage allocated for the full import."]
    pub total: ::std::os::raw::c_uint,
}
#[doc = "  @brief  Type to store a in-memory data buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiBuffer {
    #[doc = "< Begin poiner"]
    pub data: *const ::std::os::raw::c_char,
    #[doc = "< End pointer"]
    pub end: *const ::std::os::raw::c_char,
}
impl Default for aiBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod aiImporterFlags {
    #[doc = " Mixed set of flags for #aiImporterDesc, indicating some features\n  common to many importers"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = " Indicates that there is a textual encoding of the\n  file format; and that it is supported."]
    pub const aiImporterFlags_SupportTextFlavour: Type = 1;
    #[doc = " Indicates that there is a binary encoding of the\n  file format; and that it is supported."]
    pub const aiImporterFlags_SupportBinaryFlavour: Type = 2;
    #[doc = " Indicates that there is a compressed encoding of the\n  file format; and that it is supported."]
    pub const aiImporterFlags_SupportCompressedFlavour: Type = 4;
    #[doc = " Indicates that the importer reads only a very particular\n subset of the file format. This happens commonly for\n declarative or procedural formats which cannot easily\n be mapped to #aiScene"]
    pub const aiImporterFlags_LimitedSupport: Type = 8;
    #[doc = " Indicates that the importer is highly experimental and\n should be used with care. This only happens for trunk\n (i.e. SVN) versions, experimental code is not included\n in releases."]
    pub const aiImporterFlags_Experimental: Type = 16;
}
#[doc = " Meta information about a particular importer. Importers need to fill\n  this structure, but they can freely decide how talkative they are.\n  A common use case for loader meta info is a user interface\n  in which the user can choose between various import/export file\n  formats. Building such an UI by hand means a lot of maintenance\n  as importers/exporters are added to Assimp, so it might be useful\n  to have a common mechanism to query some rough importer\n  characteristics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiImporterDesc {
    #[doc = " Full name of the importer (i.e. Blender3D importer)"]
    pub mName: *const ::std::os::raw::c_char,
    #[doc = " Original author (left blank if unknown or whole assimp team)"]
    pub mAuthor: *const ::std::os::raw::c_char,
    #[doc = " Current maintainer, left blank if the author maintains"]
    pub mMaintainer: *const ::std::os::raw::c_char,
    #[doc = " Implementation comments, i.e. unimplemented features"]
    pub mComments: *const ::std::os::raw::c_char,
    #[doc = " These flags indicate some characteristics common to many\nimporters."]
    pub mFlags: ::std::os::raw::c_uint,
    #[doc = " Minimum format version that can be loaded im major.minor format,\nboth are set to 0 if there is either no version scheme\nor if the loader doesn't care."]
    pub mMinMajor: ::std::os::raw::c_uint,
    pub mMinMinor: ::std::os::raw::c_uint,
    #[doc = " Maximum format version that can be loaded im major.minor format,\nboth are set to 0 if there is either no version scheme\nor if the loader doesn't care. Loaders that expect to be\nforward-compatible to potential future format versions should\nindicate  zero, otherwise they should specify the current\nmaximum version."]
    pub mMaxMajor: ::std::os::raw::c_uint,
    pub mMaxMinor: ::std::os::raw::c_uint,
    #[doc = " List of file extensions this importer can handle.\nList entries are separated by space characters.\nAll entries are lower case without a leading dot (i.e.\n\"xml dae\" would be a valid value. Note that multiple\nimporters may respond to the same file extension -\nassimp calls all importers in the order in which they\nare registered and each importer gets the opportunity\nto load the file until one importer \"claims\" the file. Apart\nfrom file extension checks, importers typically use\nother methods to quickly reject files (i.e. magic\nwords) so this does not mean that common or generic\nfile extensions such as XML would be tediously slow."]
    pub mFileExtensions: *const ::std::os::raw::c_char,
}
impl Default for aiImporterDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the Importer description for a given extension.\n\nWill return a nullptr if no assigned importer desc. was found for the given extension\n\\param  extension   [in] The extension to look for\n\\return A pointer showing to the ImporterDesc, \\see aiImporterDesc."]
    pub fn aiGetImporterDesc(extension: *const ::std::os::raw::c_char) -> *const aiImporterDesc;
}
pub type aiLogStreamCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: *mut ::std::os::raw::c_char),
>;
#[doc = " C-API: Represents a log stream. A log stream receives all log messages and\n  streams them _somewhere_.\n  @see aiGetPredefinedLogStream\n  @see aiAttachLogStream\n  @see aiDetachLogStream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiLogStream {
    #[doc = " callback to be called"]
    pub callback: aiLogStreamCallback,
    #[doc = " user data to be passed to the callback"]
    pub user: *mut ::std::os::raw::c_char,
}
impl Default for aiLogStream {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " C-API: Represents an opaque set of settings to be used during importing.\n  @see aiCreatePropertyStore\n  @see aiReleasePropertyStore\n  @see aiImportFileExWithProperties\n  @see aiSetPropertyInteger\n  @see aiSetPropertyFloat\n  @see aiSetPropertyString\n  @see aiSetPropertyMatrix"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiPropertyStore {
    pub sentinel: ::std::os::raw::c_char,
}
#[doc = " Our own C boolean type"]
pub type aiBool = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Reads the given file and returns its content.\n\n If the call succeeds, the imported data is returned in an aiScene structure.\n The data is intended to be read-only, it stays property of the ASSIMP\n library and will be stable until aiReleaseImport() is called. After you're\n done with it, call aiReleaseImport() to free the resources associated with\n this file. If the import fails, NULL is returned instead. Call\n aiGetErrorString() to retrieve a human-readable error text.\n @param pFile Path and filename of the file to be imported,\n   expected to be a null-terminated c-string. NULL is not a valid value.\n @param pFlags Optional post processing steps to be executed after\n   a successful import. Provide a bitwise combination of the\n   #aiPostProcessSteps flags.\n @return Pointer to the imported data or NULL if the import failed."]
    pub fn aiImportFile(
        pFile: *const ::std::os::raw::c_char,
        pFlags: ::std::os::raw::c_uint,
    ) -> *const aiScene;
}
unsafe extern "C" {
    #[doc = " Reads the given file using user-defined I/O functions and returns\n   its content.\n\n If the call succeeds, the imported data is returned in an aiScene structure.\n The data is intended to be read-only, it stays property of the ASSIMP\n library and will be stable until aiReleaseImport() is called. After you're\n done with it, call aiReleaseImport() to free the resources associated with\n this file. If the import fails, NULL is returned instead. Call\n aiGetErrorString() to retrieve a human-readable error text.\n @param pFile Path and filename of the file to be imported,\n   expected to be a null-terminated c-string. NULL is not a valid value.\n @param pFlags Optional post processing steps to be executed after\n   a successful import. Provide a bitwise combination of the\n   #aiPostProcessSteps flags.\n @param pFS aiFileIO structure. Will be used to open the model file itself\n   and any other files the loader needs to open.  Pass NULL to use the default\n   implementation.\n @return Pointer to the imported data or NULL if the import failed.\n @note Include <aiFileIO.h> for the definition of #aiFileIO."]
    pub fn aiImportFileEx(
        pFile: *const ::std::os::raw::c_char,
        pFlags: ::std::os::raw::c_uint,
        pFS: *mut aiFileIO,
    ) -> *const aiScene;
}
unsafe extern "C" {
    #[doc = " Same as #aiImportFileEx, but adds an extra parameter containing importer settings.\n\n @param pFile Path and filename of the file to be imported,\n   expected to be a null-terminated c-string. NULL is not a valid value.\n @param pFlags Optional post processing steps to be executed after\n   a successful import. Provide a bitwise combination of the\n   #aiPostProcessSteps flags.\n @param pFS aiFileIO structure. Will be used to open the model file itself\n   and any other files the loader needs to open.  Pass NULL to use the default\n   implementation.\n @param pProps #aiPropertyStore instance containing import settings.\n @return Pointer to the imported data or NULL if the import failed.\n @note Include <aiFileIO.h> for the definition of #aiFileIO.\n @see aiImportFileEx"]
    pub fn aiImportFileExWithProperties(
        pFile: *const ::std::os::raw::c_char,
        pFlags: ::std::os::raw::c_uint,
        pFS: *mut aiFileIO,
        pProps: *const aiPropertyStore,
    ) -> *const aiScene;
}
unsafe extern "C" {
    #[doc = " Reads the given file from a given memory buffer,\n\n If the call succeeds, the imported data is returned in an aiScene structure.\n The data is intended to be read-only, it stays property of the ASSIMP\n library and will be stable until aiReleaseImport() is called. After you're\n done with it, call aiReleaseImport() to free the resources associated with\n this file. If the import fails, NULL is returned.\n A human-readable error description can be retrieved by calling aiGetErrorString().\n @param pBuffer Pointer to the file data\n @param pLength Length of pBuffer, in bytes\n @param pFlags Optional post processing steps to be executed after\n   a successful import. Provide a bitwise combination of the\n   #aiPostProcessSteps flags. If you wish to inspect the imported\n   scene first in order to fine-tune your post-processing setup,\n   consider to use #aiApplyPostProcessing().\n @param pHint An additional hint to the library. If this is a non empty string,\n   the library looks for a loader to support the file extension specified by pHint\n   and passes the file to the first matching loader. If this loader is unable to\n   completely the request, the library continues and tries to determine the file\n   format on its own, a task that may or may not be successful.\n   Check the return value, and you'll know ...\n @return A pointer to the imported data, NULL if the import failed.\n\n @note This is a straightforward way to decode models from memory\n buffers, but it doesn't handle model formats that spread their\n data across multiple files or even directories. Examples include\n OBJ or MD3, which outsource parts of their material info into\n external scripts. If you need full functionality, provide\n a custom IOSystem to make Assimp find these files and use\n the regular aiImportFileEx()/aiImportFileExWithProperties() API."]
    pub fn aiImportFileFromMemory(
        pBuffer: *const ::std::os::raw::c_char,
        pLength: ::std::os::raw::c_uint,
        pFlags: ::std::os::raw::c_uint,
        pHint: *const ::std::os::raw::c_char,
    ) -> *const aiScene;
}
unsafe extern "C" {
    #[doc = " Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.\n\n @param pBuffer Pointer to the file data\n @param pLength Length of pBuffer, in bytes\n @param pFlags Optional post processing steps to be executed after\n   a successful import. Provide a bitwise combination of the\n   #aiPostProcessSteps flags. If you wish to inspect the imported\n   scene first in order to fine-tune your post-processing setup,\n   consider to use #aiApplyPostProcessing().\n @param pHint An additional hint to the library. If this is a non empty string,\n   the library looks for a loader to support the file extension specified by pHint\n   and passes the file to the first matching loader. If this loader is unable to\n   completely the request, the library continues and tries to determine the file\n   format on its own, a task that may or may not be successful.\n   Check the return value, and you'll know ...\n @param pProps #aiPropertyStore instance containing import settings.\n @return A pointer to the imported data, NULL if the import failed.\n\n @note This is a straightforward way to decode models from memory\n buffers, but it doesn't handle model formats that spread their\n data across multiple files or even directories. Examples include\n OBJ or MD3, which outsource parts of their material info into\n external scripts. If you need full functionality, provide\n a custom IOSystem to make Assimp find these files and use\n the regular aiImportFileEx()/aiImportFileExWithProperties() API.\n @see aiImportFileFromMemory"]
    pub fn aiImportFileFromMemoryWithProperties(
        pBuffer: *const ::std::os::raw::c_char,
        pLength: ::std::os::raw::c_uint,
        pFlags: ::std::os::raw::c_uint,
        pHint: *const ::std::os::raw::c_char,
        pProps: *const aiPropertyStore,
    ) -> *const aiScene;
}
unsafe extern "C" {
    #[doc = " Apply post-processing to an already-imported scene.\n\n This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the\n same flags. However, you can use this separate function to inspect the imported\n scene first to fine-tune your post-processing setup.\n @param pScene Scene to work on.\n @param pFlags Provide a bitwise combination of the #aiPostProcessSteps flags.\n @return A pointer to the post-processed data. Post processing is done in-place,\n   meaning this is still the same #aiScene which you passed for pScene. However,\n   _if_ post-processing failed, the scene could now be NULL. That's quite a rare\n   case, post processing steps are not really designed to 'fail'. To be exact,\n   the #aiProcess_ValidateDataStructure flag is currently the only post processing step\n   which can actually cause the scene to be reset to NULL."]
    pub fn aiApplyPostProcessing(
        pScene: *const aiScene,
        pFlags: ::std::os::raw::c_uint,
    ) -> *const aiScene;
}
unsafe extern "C" {
    #[doc = " Get one of the predefine log streams. This is the quick'n'easy solution to\n  access Assimp's log system. Attaching a log stream can slightly reduce Assimp's\n  overall import performance.\n\n  Usage is rather simple (this will stream the log to a file, named log.txt, and\n  the stdout stream of the process:\n  @code\n    struct aiLogStream c;\n    c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE,\"log.txt\");\n    aiAttachLogStream(&c);\n    c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT,NULL);\n    aiAttachLogStream(&c);\n  @endcode\n\n  @param pStreams One of the #aiDefaultLogStream enumerated values.\n  @param file Solely for the #aiDefaultLogStream_FILE flag: specifies the file to write to.\n    Pass NULL for all other flags.\n  @return The log stream. callback is set to NULL if something went wrong."]
    pub fn aiGetPredefinedLogStream(
        pStreams: aiDefaultLogStream::Type,
        file: *const ::std::os::raw::c_char,
    ) -> aiLogStream;
}
unsafe extern "C" {
    #[doc = " Attach a custom log stream to the libraries' logging system.\n\n  Attaching a log stream can slightly reduce Assimp's overall import\n  performance. Multiple log-streams can be attached.\n  @param stream Describes the new log stream.\n  @note To ensure proper destruction of the logging system, you need to manually\n    call aiDetachLogStream() on every single log stream you attach.\n    Alternatively (for the lazy folks) #aiDetachAllLogStreams is provided."]
    pub fn aiAttachLogStream(stream: *const aiLogStream);
}
unsafe extern "C" {
    #[doc = " Enable verbose logging. Verbose logging includes debug-related stuff and\n  detailed import statistics. This can have severe impact on import performance\n  and memory consumption. However, it might be useful to find out why a file\n  didn't read correctly.\n  @param d AI_TRUE or AI_FALSE, your decision."]
    pub fn aiEnableVerboseLogging(d: aiBool);
}
unsafe extern "C" {
    #[doc = " Detach a custom log stream from the libraries' logging system.\n\n  This is the counterpart of #aiAttachLogStream. If you attached a stream,\n  don't forget to detach it again.\n  @param stream The log stream to be detached.\n  @return AI_SUCCESS if the log stream has been detached successfully.\n  @see aiDetachAllLogStreams"]
    pub fn aiDetachLogStream(stream: *const aiLogStream) -> aiReturn;
}
unsafe extern "C" {
    #[doc = " Detach all active log streams from the libraries' logging system.\n  This ensures that the logging system is terminated properly and all\n  resources allocated by it are actually freed. If you attached a stream,\n  don't forget to detach it again.\n  @see aiAttachLogStream\n  @see aiDetachLogStream"]
    pub fn aiDetachAllLogStreams();
}
unsafe extern "C" {
    #[doc = " Releases all resources associated with the given import process.\n\n Call this function after you're done with the imported data.\n @param pScene The imported data to release. NULL is a valid value."]
    pub fn aiReleaseImport(pScene: *const aiScene);
}
unsafe extern "C" {
    #[doc = " Returns the error text of the last failed import process.\n\n @return A textual description of the error that occurred at the last\n import process. NULL if there was no error. There can't be an error if you\n got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing."]
    pub fn aiGetErrorString() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns whether a given file extension is supported by ASSIMP\n\n @param szExtension Extension for which the function queries support for.\n Must include a leading dot '.'. Example: \".3ds\", \".md3\"\n @return AI_TRUE if the file extension is supported."]
    pub fn aiIsExtensionSupported(szExtension: *const ::std::os::raw::c_char) -> aiBool;
}
unsafe extern "C" {
    #[doc = " Get a list of all file extensions supported by ASSIMP.\n\n If a file extension is contained in the list this does, of course, not\n mean that ASSIMP is able to load all files with this extension.\n @param szOut String to receive the extension list.\n Format of the list: \"*.3ds;*.obj;*.dae\". NULL is not a valid parameter."]
    pub fn aiGetExtensionList(szOut: *mut aiString);
}
unsafe extern "C" {
    #[doc = " Get the approximated storage required by an imported asset\n @param pIn Input asset.\n @param in Data structure to be filled."]
    pub fn aiGetMemoryRequirements(pIn: *const aiScene, in_: *mut aiMemoryInfo);
}
unsafe extern "C" {
    #[doc = " Returns an embedded texture, or nullptr.\n @param pIn Input asset.\n @param filename Texture path extracted from aiGetMaterialString."]
    pub fn aiGetEmbeddedTexture(
        pIn: *const aiScene,
        filename: *const ::std::os::raw::c_char,
    ) -> *const aiTexture;
}
unsafe extern "C" {
    #[doc = " Create an empty property store. Property stores are used to collect import\n  settings.\n @return New property store. Property stores need to be manually destroyed using\n   the #aiReleasePropertyStore API function."]
    pub fn aiCreatePropertyStore() -> *mut aiPropertyStore;
}
unsafe extern "C" {
    #[doc = " Delete a property store.\n @param p Property store to be deleted."]
    pub fn aiReleasePropertyStore(p: *mut aiPropertyStore);
}
unsafe extern "C" {
    #[doc = " Set an integer property.\n\n  This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C\n  interface, properties are always shared by all imports. It is not possible to\n  specify them per import.\n\n @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.\n @param szName Name of the configuration property to be set. All supported\n   public properties are defined in the config.h header file (AI_CONFIG_XXX).\n @param value New value for the property"]
    pub fn aiSetImportPropertyInteger(
        store: *mut aiPropertyStore,
        szName: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Set a floating-point property.\n\n  This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C\n  interface, properties are always shared by all imports. It is not possible to\n  specify them per import.\n\n @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.\n @param szName Name of the configuration property to be set. All supported\n   public properties are defined in the config.h header file (AI_CONFIG_XXX).\n @param value New value for the property"]
    pub fn aiSetImportPropertyFloat(
        store: *mut aiPropertyStore,
        szName: *const ::std::os::raw::c_char,
        value: ai_real,
    );
}
unsafe extern "C" {
    #[doc = " Set a string property.\n\n  This is the C-version of #Assimp::Importer::SetPropertyString(). In the C\n  interface, properties are always shared by all imports. It is not possible to\n  specify them per import.\n\n @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.\n @param szName Name of the configuration property to be set. All supported\n   public properties are defined in the config.h header file (AI_CONFIG_XXX).\n @param st New value for the property"]
    pub fn aiSetImportPropertyString(
        store: *mut aiPropertyStore,
        szName: *const ::std::os::raw::c_char,
        st: *const aiString,
    );
}
unsafe extern "C" {
    #[doc = " Set a matrix property.\n\n  This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C\n  interface, properties are always shared by all imports. It is not possible to\n  specify them per import.\n\n @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.\n @param szName Name of the configuration property to be set. All supported\n   public properties are defined in the config.h header file (AI_CONFIG_XXX).\n @param mat New value for the property"]
    pub fn aiSetImportPropertyMatrix(
        store: *mut aiPropertyStore,
        szName: *const ::std::os::raw::c_char,
        mat: *const aiMatrix4x4,
    );
}
unsafe extern "C" {
    #[doc = " Construct a quaternion from a 3x3 rotation matrix.\n  @param quat Receives the output quaternion.\n  @param mat Matrix to 'quaternionize'.\n  @see aiQuaternion(const aiMatrix3x3& pRotMatrix)"]
    pub fn aiCreateQuaternionFromMatrix(quat: *mut aiQuaternion, mat: *const aiMatrix3x3);
}
unsafe extern "C" {
    #[doc = " Decompose a transformation matrix into its rotational, translational and\n  scaling components.\n\n @param mat Matrix to decompose\n @param scaling Receives the scaling component\n @param rotation Receives the rotational component\n @param position Receives the translational component.\n @see aiMatrix4x4::Decompose (aiVector3D&, aiQuaternion&, aiVector3D&) const;"]
    pub fn aiDecomposeMatrix(
        mat: *const aiMatrix4x4,
        scaling: *mut aiVector3D,
        rotation: *mut aiQuaternion,
        position: *mut aiVector3D,
    );
}
unsafe extern "C" {
    #[doc = " Transpose a 4x4 matrix.\n  @param mat Pointer to the matrix to be transposed"]
    pub fn aiTransposeMatrix4(mat: *mut aiMatrix4x4);
}
unsafe extern "C" {
    #[doc = " Transpose a 3x3 matrix.\n  @param mat Pointer to the matrix to be transposed"]
    pub fn aiTransposeMatrix3(mat: *mut aiMatrix3x3);
}
unsafe extern "C" {
    #[doc = " Transform a vector by a 3x3 matrix\n  @param vec Vector to be transformed.\n  @param mat Matrix to transform the vector with."]
    pub fn aiTransformVecByMatrix3(vec: *mut aiVector3D, mat: *const aiMatrix3x3);
}
unsafe extern "C" {
    #[doc = " Transform a vector by a 4x4 matrix\n  @param vec Vector to be transformed.\n  @param mat Matrix to transform the vector with."]
    pub fn aiTransformVecByMatrix4(vec: *mut aiVector3D, mat: *const aiMatrix4x4);
}
unsafe extern "C" {
    #[doc = " Multiply two 4x4 matrices.\n  @param dst First factor, receives result.\n  @param src Matrix to be multiplied with 'dst'."]
    pub fn aiMultiplyMatrix4(dst: *mut aiMatrix4x4, src: *const aiMatrix4x4);
}
unsafe extern "C" {
    #[doc = " Multiply two 3x3 matrices.\n  @param dst First factor, receives result.\n  @param src Matrix to be multiplied with 'dst'."]
    pub fn aiMultiplyMatrix3(dst: *mut aiMatrix3x3, src: *const aiMatrix3x3);
}
unsafe extern "C" {
    #[doc = " Get a 3x3 identity matrix.\n  @param mat Matrix to receive its personal identity"]
    pub fn aiIdentityMatrix3(mat: *mut aiMatrix3x3);
}
unsafe extern "C" {
    #[doc = " Get a 4x4 identity matrix.\n  @param mat Matrix to receive its personal identity"]
    pub fn aiIdentityMatrix4(mat: *mut aiMatrix4x4);
}
unsafe extern "C" {
    #[doc = " Returns the number of import file formats available in the current Assimp build.\n Use aiGetImportFormatDescription() to retrieve infos of a specific import format."]
    pub fn aiGetImportFormatCount() -> usize;
}
unsafe extern "C" {
    #[doc = " Returns a description of the nth import file format. Use #aiGetImportFormatCount()\n to learn how many import formats are supported.\n @param pIndex Index of the import format to retrieve information for. Valid range is\n    0 to #aiGetImportFormatCount()\n @return A description of that specific import format. NULL if pIndex is out of range."]
    pub fn aiGetImportFormatDescription(pIndex: usize) -> *const aiImporterDesc;
}
unsafe extern "C" {
    #[doc = " Check if 2D vectors are equal.\n  @param a First vector to compare\n  @param b Second vector to compare\n  @return 1 if the vectors are equal\n  @return 0 if the vectors are not equal"]
    pub fn aiVector2AreEqual(a: *const aiVector2D, b: *const aiVector2D) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if 2D vectors are equal using epsilon.\n  @param a First vector to compare\n  @param b Second vector to compare\n  @param epsilon Epsilon\n  @return 1 if the vectors are equal\n  @return 0 if the vectors are not equal"]
    pub fn aiVector2AreEqualEpsilon(
        a: *const aiVector2D,
        b: *const aiVector2D,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add 2D vectors.\n  @param dst First addend, receives result.\n  @param src Vector to be added to 'dst'."]
    pub fn aiVector2Add(dst: *mut aiVector2D, src: *const aiVector2D);
}
unsafe extern "C" {
    #[doc = " Subtract 2D vectors.\n  @param dst Minuend, receives result.\n  @param src Vector to be subtracted from 'dst'."]
    pub fn aiVector2Subtract(dst: *mut aiVector2D, src: *const aiVector2D);
}
unsafe extern "C" {
    #[doc = " Multiply a 2D vector by a scalar.\n  @param dst Vector to be scaled by \\p s\n  @param s Scale factor"]
    pub fn aiVector2Scale(dst: *mut aiVector2D, s: f32);
}
unsafe extern "C" {
    #[doc = " Multiply each component of a 2D vector with\n  the components of another vector.\n  @param dst First vector, receives result\n  @param other Second vector"]
    pub fn aiVector2SymMul(dst: *mut aiVector2D, other: *const aiVector2D);
}
unsafe extern "C" {
    #[doc = " Divide a 2D vector by a scalar.\n  @param dst Vector to be divided by \\p s\n  @param s Scalar divisor"]
    pub fn aiVector2DivideByScalar(dst: *mut aiVector2D, s: f32);
}
unsafe extern "C" {
    #[doc = " Divide each component of a 2D vector by\n  the components of another vector.\n  @param dst Vector as the dividend\n  @param v Vector as the divisor"]
    pub fn aiVector2DivideByVector(dst: *mut aiVector2D, v: *mut aiVector2D);
}
unsafe extern "C" {
    #[doc = " Get the length of a 2D vector.\n  @return v Vector to evaluate"]
    pub fn aiVector2Length(v: *const aiVector2D) -> ai_real;
}
unsafe extern "C" {
    #[doc = " Get the squared length of a 2D vector.\n  @return v Vector to evaluate"]
    pub fn aiVector2SquareLength(v: *const aiVector2D) -> ai_real;
}
unsafe extern "C" {
    #[doc = " Negate a 2D vector.\n  @param dst Vector to be negated"]
    pub fn aiVector2Negate(dst: *mut aiVector2D);
}
unsafe extern "C" {
    #[doc = " Get the dot product of 2D vectors.\n  @param a First vector\n  @param b Second vector\n  @return The dot product of vectors"]
    pub fn aiVector2DotProduct(a: *const aiVector2D, b: *const aiVector2D) -> ai_real;
}
unsafe extern "C" {
    #[doc = " Normalize a 2D vector.\n  @param v Vector to normalize"]
    pub fn aiVector2Normalize(v: *mut aiVector2D);
}
unsafe extern "C" {
    #[doc = " Check if 3D vectors are equal.\n  @param a First vector to compare\n  @param b Second vector to compare\n  @return 1 if the vectors are equal\n  @return 0 if the vectors are not equal"]
    pub fn aiVector3AreEqual(a: *const aiVector3D, b: *const aiVector3D) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if 3D vectors are equal using epsilon.\n  @param a First vector to compare\n  @param b Second vector to compare\n  @param epsilon Epsilon\n  @return 1 if the vectors are equal\n  @return 0 if the vectors are not equal"]
    pub fn aiVector3AreEqualEpsilon(
        a: *const aiVector3D,
        b: *const aiVector3D,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if vector \\p a is less than vector \\p b.\n  @param a First vector to compare\n  @param b Second vector to compare\n  @param epsilon Epsilon\n  @return 1 if \\p a is less than \\p b\n  @return 0 if \\p a is equal or greater than \\p b"]
    pub fn aiVector3LessThan(a: *const aiVector3D, b: *const aiVector3D) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add 3D vectors.\n  @param dst First addend, receives result.\n  @param src Vector to be added to 'dst'."]
    pub fn aiVector3Add(dst: *mut aiVector3D, src: *const aiVector3D);
}
unsafe extern "C" {
    #[doc = " Subtract 3D vectors.\n  @param dst Minuend, receives result.\n  @param src Vector to be subtracted from 'dst'."]
    pub fn aiVector3Subtract(dst: *mut aiVector3D, src: *const aiVector3D);
}
unsafe extern "C" {
    #[doc = " Multiply a 3D vector by a scalar.\n  @param dst Vector to be scaled by \\p s\n  @param s Scale factor"]
    pub fn aiVector3Scale(dst: *mut aiVector3D, s: f32);
}
unsafe extern "C" {
    #[doc = " Multiply each component of a 3D vector with\n  the components of another vector.\n  @param dst First vector, receives result\n  @param other Second vector"]
    pub fn aiVector3SymMul(dst: *mut aiVector3D, other: *const aiVector3D);
}
unsafe extern "C" {
    #[doc = " Divide a 3D vector by a scalar.\n  @param dst Vector to be divided by \\p s\n  @param s Scalar divisor"]
    pub fn aiVector3DivideByScalar(dst: *mut aiVector3D, s: f32);
}
unsafe extern "C" {
    #[doc = " Divide each component of a 3D vector by\n  the components of another vector.\n  @param dst Vector as the dividend\n  @param v Vector as the divisor"]
    pub fn aiVector3DivideByVector(dst: *mut aiVector3D, v: *mut aiVector3D);
}
unsafe extern "C" {
    #[doc = " Get the length of a 3D vector.\n  @return v Vector to evaluate"]
    pub fn aiVector3Length(v: *const aiVector3D) -> ai_real;
}
unsafe extern "C" {
    #[doc = " Get the squared length of a 3D vector.\n  @return v Vector to evaluate"]
    pub fn aiVector3SquareLength(v: *const aiVector3D) -> ai_real;
}
unsafe extern "C" {
    #[doc = " Negate a 3D vector.\n  @param dst Vector to be negated"]
    pub fn aiVector3Negate(dst: *mut aiVector3D);
}
unsafe extern "C" {
    #[doc = " Get the dot product of 3D vectors.\n  @param a First vector\n  @param b Second vector\n  @return The dot product of vectors"]
    pub fn aiVector3DotProduct(a: *const aiVector3D, b: *const aiVector3D) -> ai_real;
}
unsafe extern "C" {
    #[doc = " Get cross product of 3D vectors.\n  @param dst Vector to receive the result.\n  @param a First vector\n  @param b Second vector\n  @return The dot product of vectors"]
    pub fn aiVector3CrossProduct(dst: *mut aiVector3D, a: *const aiVector3D, b: *const aiVector3D);
}
unsafe extern "C" {
    #[doc = " Normalize a 3D vector.\n  @param v Vector to normalize"]
    pub fn aiVector3Normalize(v: *mut aiVector3D);
}
unsafe extern "C" {
    #[doc = " Check for division by zero and normalize a 3D vector.\n  @param v Vector to normalize"]
    pub fn aiVector3NormalizeSafe(v: *mut aiVector3D);
}
unsafe extern "C" {
    #[doc = " Rotate a 3D vector by a quaternion.\n  @param v The vector to rotate by \\p q\n  @param q Quaternion to use to rotate \\p v"]
    pub fn aiVector3RotateByQuaternion(v: *mut aiVector3D, q: *const aiQuaternion);
}
unsafe extern "C" {
    #[doc = " Construct a 3x3 matrix from a 4x4 matrix.\n  @param dst Receives the output matrix\n  @param mat The 4x4 matrix to use"]
    pub fn aiMatrix3FromMatrix4(dst: *mut aiMatrix3x3, mat: *const aiMatrix4x4);
}
unsafe extern "C" {
    #[doc = " Construct a 3x3 matrix from a quaternion.\n  @param mat Receives the output matrix\n  @param q The quaternion matrix to use"]
    pub fn aiMatrix3FromQuaternion(mat: *mut aiMatrix3x3, q: *const aiQuaternion);
}
unsafe extern "C" {
    #[doc = " Check if 3x3 matrices are equal.\n  @param a First matrix to compare\n  @param b Second matrix to compare\n  @return 1 if the matrices are equal\n  @return 0 if the matrices are not equal"]
    pub fn aiMatrix3AreEqual(a: *const aiMatrix3x3, b: *const aiMatrix3x3)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if 3x3 matrices are equal.\n  @param a First matrix to compare\n  @param b Second matrix to compare\n  @param epsilon Epsilon\n  @return 1 if the matrices are equal\n  @return 0 if the matrices are not equal"]
    pub fn aiMatrix3AreEqualEpsilon(
        a: *const aiMatrix3x3,
        b: *const aiMatrix3x3,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Invert a 3x3 matrix.\n  @param mat Matrix to invert"]
    pub fn aiMatrix3Inverse(mat: *mut aiMatrix3x3);
}
unsafe extern "C" {
    #[doc = " Get the determinant of a 3x3 matrix.\n  @param mat Matrix to get the determinant from"]
    pub fn aiMatrix3Determinant(mat: *const aiMatrix3x3) -> ai_real;
}
unsafe extern "C" {
    #[doc = " Get a 3x3 rotation matrix around the Z axis.\n  @param mat Receives the output matrix\n  @param angle Rotation angle, in radians"]
    pub fn aiMatrix3RotationZ(mat: *mut aiMatrix3x3, angle: f32);
}
unsafe extern "C" {
    #[doc = " Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.\n  @param mat Receives the output matrix\n  @param axis Rotation axis, should be a normalized vector\n  @param angle Rotation angle, in radians"]
    pub fn aiMatrix3FromRotationAroundAxis(
        mat: *mut aiMatrix3x3,
        axis: *const aiVector3D,
        angle: f32,
    );
}
unsafe extern "C" {
    #[doc = " Get a 3x3 translation matrix.\n  @param mat Receives the output matrix\n  @param translation The translation vector"]
    pub fn aiMatrix3Translation(mat: *mut aiMatrix3x3, translation: *const aiVector2D);
}
unsafe extern "C" {
    #[doc = " Create a 3x3 matrix that rotates one vector to another vector.\n  @param mat Receives the output matrix\n  @param from Vector to rotate from\n  @param to Vector to rotate to"]
    pub fn aiMatrix3FromTo(mat: *mut aiMatrix3x3, from: *const aiVector3D, to: *const aiVector3D);
}
unsafe extern "C" {
    #[doc = " Construct a 4x4 matrix from a 3x3 matrix.\n  @param dst Receives the output matrix\n  @param mat The 3x3 matrix to use"]
    pub fn aiMatrix4FromMatrix3(dst: *mut aiMatrix4x4, mat: *const aiMatrix3x3);
}
unsafe extern "C" {
    #[doc = " Construct a 4x4 matrix from scaling, rotation and position.\n  @param mat Receives the output matrix.\n  @param scaling The scaling for the x,y,z axes\n  @param rotation The rotation as a hamilton quaternion\n  @param position The position for the x,y,z axes"]
    pub fn aiMatrix4FromScalingQuaternionPosition(
        mat: *mut aiMatrix4x4,
        scaling: *const aiVector3D,
        rotation: *const aiQuaternion,
        position: *const aiVector3D,
    );
}
unsafe extern "C" {
    #[doc = " Add 4x4 matrices.\n  @param dst First addend, receives result.\n  @param src Matrix to be added to 'dst'."]
    pub fn aiMatrix4Add(dst: *mut aiMatrix4x4, src: *const aiMatrix4x4);
}
unsafe extern "C" {
    #[doc = " Check if 4x4 matrices are equal.\n  @param a First matrix to compare\n  @param b Second matrix to compare\n  @return 1 if the matrices are equal\n  @return 0 if the matrices are not equal"]
    pub fn aiMatrix4AreEqual(a: *const aiMatrix4x4, b: *const aiMatrix4x4)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if 4x4 matrices are equal.\n  @param a First matrix to compare\n  @param b Second matrix to compare\n  @param epsilon Epsilon\n  @return 1 if the matrices are equal\n  @return 0 if the matrices are not equal"]
    pub fn aiMatrix4AreEqualEpsilon(
        a: *const aiMatrix4x4,
        b: *const aiMatrix4x4,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Invert a 4x4 matrix.\n  @param result Matrix to invert"]
    pub fn aiMatrix4Inverse(mat: *mut aiMatrix4x4);
}
unsafe extern "C" {
    #[doc = " Get the determinant of a 4x4 matrix.\n  @param mat Matrix to get the determinant from\n  @return The determinant of the matrix"]
    pub fn aiMatrix4Determinant(mat: *const aiMatrix4x4) -> ai_real;
}
unsafe extern "C" {
    #[doc = " Returns true of the matrix is the identity matrix.\n  @param mat Matrix to get the determinant from\n  @return 1 if \\p mat is an identity matrix.\n  @return 0 if \\p mat is not an identity matrix."]
    pub fn aiMatrix4IsIdentity(mat: *const aiMatrix4x4) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decompose a transformation matrix into its scaling,\n  rotational as euler angles, and translational components.\n\n @param mat Matrix to decompose\n @param scaling Receives the output scaling for the x,y,z axes\n @param rotation Receives the output rotation as a Euler angles\n @param position Receives the output position for the x,y,z axes"]
    pub fn aiMatrix4DecomposeIntoScalingEulerAnglesPosition(
        mat: *const aiMatrix4x4,
        scaling: *mut aiVector3D,
        rotation: *mut aiVector3D,
        position: *mut aiVector3D,
    );
}
unsafe extern "C" {
    #[doc = " Decompose a transformation matrix into its scaling,\n  rotational split into an axis and rotational angle,\n  and it's translational components.\n\n @param mat Matrix to decompose\n @param rotation Receives the rotational component\n @param axis Receives the output rotation axis\n @param angle Receives the output rotation angle\n @param position Receives the output position for the x,y,z axes."]
    pub fn aiMatrix4DecomposeIntoScalingAxisAnglePosition(
        mat: *const aiMatrix4x4,
        scaling: *mut aiVector3D,
        axis: *mut aiVector3D,
        angle: *mut ai_real,
        position: *mut aiVector3D,
    );
}
unsafe extern "C" {
    #[doc = " Decompose a transformation matrix into its rotational and\n  translational components.\n\n @param mat Matrix to decompose\n @param rotation Receives the rotational component\n @param position Receives the translational component."]
    pub fn aiMatrix4DecomposeNoScaling(
        mat: *const aiMatrix4x4,
        rotation: *mut aiQuaternion,
        position: *mut aiVector3D,
    );
}
unsafe extern "C" {
    #[doc = " Creates a 4x4 matrix from a set of euler angles.\n  @param mat Receives the output matrix\n  @param x Rotation angle for the x-axis, in radians\n  @param y Rotation angle for the y-axis, in radians\n  @param z Rotation angle for the z-axis, in radians"]
    pub fn aiMatrix4FromEulerAngles(mat: *mut aiMatrix4x4, x: f32, y: f32, z: f32);
}
unsafe extern "C" {
    #[doc = " Get a 4x4 rotation matrix around the X axis.\n  @param mat Receives the output matrix\n  @param angle Rotation angle, in radians"]
    pub fn aiMatrix4RotationX(mat: *mut aiMatrix4x4, angle: f32);
}
unsafe extern "C" {
    #[doc = " Get a 4x4 rotation matrix around the Y axis.\n  @param mat Receives the output matrix\n  @param angle Rotation angle, in radians"]
    pub fn aiMatrix4RotationY(mat: *mut aiMatrix4x4, angle: f32);
}
unsafe extern "C" {
    #[doc = " Get a 4x4 rotation matrix around the Z axis.\n  @param mat Receives the output matrix\n  @param angle Rotation angle, in radians"]
    pub fn aiMatrix4RotationZ(mat: *mut aiMatrix4x4, angle: f32);
}
unsafe extern "C" {
    #[doc = " Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.\n  @param mat Receives the output matrix\n  @param axis Rotation axis, should be a normalized vector\n  @param angle Rotation angle, in radians"]
    pub fn aiMatrix4FromRotationAroundAxis(
        mat: *mut aiMatrix4x4,
        axis: *const aiVector3D,
        angle: f32,
    );
}
unsafe extern "C" {
    #[doc = " Get a 4x4 translation matrix.\n  @param mat Receives the output matrix\n  @param translation The translation vector"]
    pub fn aiMatrix4Translation(mat: *mut aiMatrix4x4, translation: *const aiVector3D);
}
unsafe extern "C" {
    #[doc = " Get a 4x4 scaling matrix.\n  @param mat Receives the output matrix\n  @param scaling The scaling vector"]
    pub fn aiMatrix4Scaling(mat: *mut aiMatrix4x4, scaling: *const aiVector3D);
}
unsafe extern "C" {
    #[doc = " Create a 4x4 matrix that rotates one vector to another vector.\n  @param mat Receives the output matrix\n  @param from Vector to rotate from\n  @param to Vector to rotate to"]
    pub fn aiMatrix4FromTo(mat: *mut aiMatrix4x4, from: *const aiVector3D, to: *const aiVector3D);
}
unsafe extern "C" {
    #[doc = " Create a Quaternion from euler angles.\n  @param q Receives the output quaternion\n  @param x Rotation angle for the x-axis, in radians\n  @param y Rotation angle for the y-axis, in radians\n  @param z Rotation angle for the z-axis, in radians"]
    pub fn aiQuaternionFromEulerAngles(q: *mut aiQuaternion, x: f32, y: f32, z: f32);
}
unsafe extern "C" {
    #[doc = " Create a Quaternion from an axis angle pair.\n  @param q Receives the output quaternion\n  @param axis The orientation axis\n  @param angle The rotation angle, in radians"]
    pub fn aiQuaternionFromAxisAngle(q: *mut aiQuaternion, axis: *const aiVector3D, angle: f32);
}
unsafe extern "C" {
    #[doc = " Create a Quaternion from a normalized quaternion stored\n  in a 3D vector.\n  @param q Receives the output quaternion\n  @param normalized The vector that stores the quaternion"]
    pub fn aiQuaternionFromNormalizedQuaternion(
        q: *mut aiQuaternion,
        normalized: *const aiVector3D,
    );
}
unsafe extern "C" {
    #[doc = " Check if quaternions are equal.\n  @param a First quaternion to compare\n  @param b Second quaternion to compare\n  @return 1 if the quaternions are equal\n  @return 0 if the quaternions are not equal"]
    pub fn aiQuaternionAreEqual(
        a: *const aiQuaternion,
        b: *const aiQuaternion,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if quaternions are equal using epsilon.\n  @param a First quaternion to compare\n  @param b Second quaternion to compare\n  @param epsilon Epsilon\n  @return 1 if the quaternions are equal\n  @return 0 if the quaternions are not equal"]
    pub fn aiQuaternionAreEqualEpsilon(
        a: *const aiQuaternion,
        b: *const aiQuaternion,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Normalize a quaternion.\n  @param q Quaternion to normalize"]
    pub fn aiQuaternionNormalize(q: *mut aiQuaternion);
}
unsafe extern "C" {
    #[doc = " Compute quaternion conjugate.\n  @param q Quaternion to compute conjugate,\n           receives the output quaternion"]
    pub fn aiQuaternionConjugate(q: *mut aiQuaternion);
}
unsafe extern "C" {
    #[doc = " Multiply quaternions.\n  @param dst First quaternion, receives the output quaternion\n  @param q Second quaternion"]
    pub fn aiQuaternionMultiply(dst: *mut aiQuaternion, q: *const aiQuaternion);
}
unsafe extern "C" {
    #[doc = " Performs a spherical interpolation between two quaternions.\n @param dst Receives the quaternion resulting from the interpolation.\n @param start Quaternion when factor == 0\n @param end Quaternion when factor == 1\n @param factor Interpolation factor between 0 and 1"]
    pub fn aiQuaternionInterpolate(
        dst: *mut aiQuaternion,
        start: *const aiQuaternion,
        end: *const aiQuaternion,
        factor: f32,
    );
}
#[doc = " @brief Helper structure to represent a texel in a ARGB8888 format\n\n  Used by aiTexture."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiTexel {
    pub b: ::std::os::raw::c_uchar,
    pub g: ::std::os::raw::c_uchar,
    pub r: ::std::os::raw::c_uchar,
    pub a: ::std::os::raw::c_uchar,
}
#[doc = " Helper structure to describe an embedded texture\n\n Normally textures are contained in external files but some file formats embed\n them directly in the model file. There are two types of embedded textures:\n 1. Uncompressed textures. The color data is given in an uncompressed format.\n 2. Compressed textures stored in a file format like png or jpg. The raw file\n bytes are given so the application must utilize an image decoder (e.g. DevIL) to\n get access to the actual color data.\n\n Embedded textures are referenced from materials using strings like \"*0\", \"*1\", etc.\n as the texture paths (a single asterisk character followed by the\n zero-based index of the texture in the aiScene::mTextures array)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiTexture {
    #[doc = " Width of the texture, in pixels\n\n If mHeight is zero the texture is compressed in a format\n like JPEG. In this case mWidth specifies the size of the\n memory area pcData is pointing to, in bytes."]
    pub mWidth: ::std::os::raw::c_uint,
    #[doc = " Height of the texture, in pixels\n\n If this value is zero, pcData points to an compressed texture\n in any format (e.g. JPEG)."]
    pub mHeight: ::std::os::raw::c_uint,
    #[doc = " A hint from the loader to make it easier for applications\n  to determine the type of embedded textures.\n\n If mHeight != 0 this member is show how data is packed. Hint will consist of\n two parts: channel order and channel bitness (count of the bits for every\n color channel). For simple parsing by the viewer it's better to not omit\n absent color channel and just use 0 for bitness. For example:\n 1. Image contain RGBA and 8 bit per channel, achFormatHint == \"rgba8888\";\n 2. Image contain ARGB and 8 bit per channel, achFormatHint == \"argb8888\";\n 3. Image contain RGB and 5 bit for R and B channels and 6 bit for G channel, achFormatHint == \"rgba5650\";\n 4. One color image with B channel and 1 bit for it, achFormatHint == \"rgba0010\";\n If mHeight == 0 then achFormatHint is set set to '\\\\0\\\\0\\\\0\\\\0' if the loader has no additional\n information about the texture file format used OR the\n file extension of the format without a trailing dot. If there\n are multiple file extensions for a format, the shortest\n extension is chosen (JPEG maps to 'jpg', not to 'jpeg').\n E.g. 'dds\\\\0', 'pcx\\\\0', 'jpg\\\\0'.  All characters are lower-case.\n The fourth character will always be '\\\\0'."]
    pub achFormatHint: [::std::os::raw::c_char; 9usize],
    #[doc = " Data of the texture.\n\n Points to an array of mWidth * mHeight aiTexel's.\n The format of the texture data shall always be ARGB8888 if the texture-hint of the type is empty.\n If the hint is not empty you can interpret the format by looking into this hint.\n make the implementation for user of the library as easy\n as possible. If mHeight = 0 this is a pointer to a memory\n buffer of size mWidth containing the compressed texture\n data. Good luck, have fun!"]
    pub pcData: *mut aiTexel,
    #[doc = " Texture original filename\n\n Used to get the texture reference"]
    pub mFilename: aiString,
}
impl Default for aiTexture {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  An axis-aligned bounding box."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiAABB {
    pub mMin: aiVector3D,
    pub mMax: aiVector3D,
}
#[doc = " @brief A single face in a mesh, referring to multiple vertices.\n\n If mNumIndices is 3, we call the face 'triangle', for mNumIndices > 3\n it's called 'polygon' (hey, that's just a definition!).\n <br>\n aiMesh::mPrimitiveTypes can be queried to quickly examine which types of\n primitive are actually present in a mesh. The #aiProcess_SortByPType flag\n executes a special post-processing algorithm which splits meshes with\n *different* primitive types mixed up (e.g. lines and triangles) in several\n 'clean' sub-meshes. Furthermore there is a configuration option (\n #AI_CONFIG_PP_SBP_REMOVE) to force #aiProcess_SortByPType to remove\n specific kinds of primitives from the imported scene, completely and forever.\n In many cases you'll probably want to set this setting to\n @code\n aiPrimitiveType_LINE|aiPrimitiveType_POINT\n @endcode\n Together with the #aiProcess_Triangulate flag you can then be sure that\n #aiFace::mNumIndices is always 3.\n @note Take a look at the @link data Data Structures page @endlink for\n more information on the layout and winding order of a face."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiFace {
    #[doc = "! Number of indices defining this face.\n! The maximum value for this member is #AI_MAX_FACE_INDICES."]
    pub mNumIndices: ::std::os::raw::c_uint,
    #[doc = "! Pointer to the indices array. Size of the array is given in numIndices."]
    pub mIndices: *mut ::std::os::raw::c_uint,
}
impl Default for aiFace {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A single influence of a bone on a vertex."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiVertexWeight {
    #[doc = "! Index of the vertex which is influenced by the bone."]
    pub mVertexId: ::std::os::raw::c_uint,
    #[doc = "! The strength of the influence in the range (0...1).\n! The influence from all bones at one vertex amounts to 1."]
    pub mWeight: ai_real,
}
#[doc = " @brief A single bone of a mesh.\n\n  A bone has a name by which it can be found in the frame hierarchy and by\n  which it can be addressed by animations. In addition it has a number of\n  influences on vertices, and a matrix relating the mesh position to the\n  position of the bone at the time of binding."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiBone {
    #[doc = " The name of the bone."]
    pub mName: aiString,
    #[doc = " The number of vertices affected by this bone.\n The maximum value for this member is #AI_MAX_BONE_WEIGHTS."]
    pub mNumWeights: ::std::os::raw::c_uint,
    #[doc = " The bone armature node - used for skeleton conversion\n you must enable aiProcess_PopulateArmatureData to populate this"]
    pub mArmature: *mut aiNode,
    #[doc = " The bone node in the scene - used for skeleton conversion\n you must enable aiProcess_PopulateArmatureData to populate this"]
    pub mNode: *mut aiNode,
    #[doc = " The influence weights of this bone, by vertex index."]
    pub mWeights: *mut aiVertexWeight,
    #[doc = " Matrix that transforms from mesh space to bone space in bind pose.\n\n This matrix describes the position of the mesh\n in the local space of this bone when the skeleton was bound.\n Thus it can be used directly to determine a desired vertex position,\n given the world-space transform of the bone when animated,\n and the position of the vertex in mesh space.\n\n It is sometimes called an inverse-bind matrix,\n or inverse bind pose matrix."]
    pub mOffsetMatrix: aiMatrix4x4,
}
impl Default for aiBone {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod aiPrimitiveType {
    #[doc = " @brief Enumerates the types of geometric primitives supported by Assimp.\n\n  @see aiFace Face data structure\n  @see aiProcess_SortByPType Per-primitive sorting of meshes\n  @see aiProcess_Triangulate Automatic triangulation\n  @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = " @brief A point primitive.\n\n This is just a single vertex in the virtual world,\n #aiFace contains just one index for such a primitive."]
    pub const aiPrimitiveType_POINT: Type = 1;
    #[doc = " @brief A line primitive.\n\n This is a line defined through a start and an end position.\n #aiFace contains exactly two indices for such a primitive."]
    pub const aiPrimitiveType_LINE: Type = 2;
    #[doc = " @brief A triangular primitive.\n\n A triangle consists of three indices."]
    pub const aiPrimitiveType_TRIANGLE: Type = 4;
    #[doc = " @brief A higher-level polygon with more than 3 edges.\n\n A triangle is a polygon, but polygon in this context means\n \"all polygons that are not triangles\". The \"Triangulate\"-Step\n is provided for your convenience, it splits all polygons in\n triangles (which are much easier to handle)."]
    pub const aiPrimitiveType_POLYGON: Type = 8;
    #[doc = " @brief A flag to determine whether this triangles only mesh is NGON encoded.\n\n NGON encoding is a special encoding that tells whether 2 or more consecutive triangles\n should be considered as a triangle fan. This is identified by looking at the first vertex index.\n 2 consecutive triangles with the same 1st vertex index are part of the same\n NGON.\n\n At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as\n triangles, as usual after a triangulation pass.\n\n To get an NGON encoded mesh, please use the aiProcess_Triangulate post process.\n\n @see aiProcess_Triangulate\n @link https://github.com/KhronosGroup/glTF/pull/1620"]
    pub const aiPrimitiveType_NGONEncodingFlag: Type = 16;
    pub const _aiPrimitiveType_Force32Bit: Type = 2147483647;
}
#[doc = " @brief An AnimMesh is an attachment to an #aiMesh stores per-vertex\n  animations for a particular frame.\n\n  You may think of an #aiAnimMesh as a `patch` for the host mesh, which\n  replaces only certain vertex data streams at a particular time.\n  Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).\n  The actual relationship between the time line and anim meshes is\n  established by #aiMeshAnim, which references singular mesh attachments\n  by their ID and binds them to a time offset."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiAnimMesh {
    #[doc = "Anim Mesh name"]
    pub mName: aiString,
    #[doc = " Replacement for aiMesh::mVertices. If this array is non-nullptr,\n  it *must* contain mNumVertices entries. The corresponding\n  array in the host mesh must be non-nullptr as well - animation\n  meshes may neither add or nor remove vertex components (if\n  a replacement array is nullptr and the corresponding source\n  array is not, the source data is taken instead)"]
    pub mVertices: *mut aiVector3D,
    #[doc = " Replacement for aiMesh::mNormals."]
    pub mNormals: *mut aiVector3D,
    #[doc = " Replacement for aiMesh::mTangents."]
    pub mTangents: *mut aiVector3D,
    #[doc = " Replacement for aiMesh::mBitangents."]
    pub mBitangents: *mut aiVector3D,
    #[doc = " Replacement for aiMesh::mColors"]
    pub mColors: [*mut aiColor4D; 8usize],
    #[doc = " Replacement for aiMesh::mTextureCoords"]
    pub mTextureCoords: [*mut aiVector3D; 8usize],
    #[doc = " The number of vertices in the aiAnimMesh, and thus the length of all\n the member arrays.\n\n This has always the same value as the mNumVertices property in the\n corresponding aiMesh. It is duplicated here merely to make the length\n of the member arrays accessible even if the aiMesh is not known, e.g.\n from language bindings."]
    pub mNumVertices: ::std::os::raw::c_uint,
    #[doc = " Weight of the AnimMesh."]
    pub mWeight: f32,
}
impl Default for aiAnimMesh {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " @brief Enumerates the methods of mesh morphing supported by Assimp."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiMorphingMethod {
    #[doc = " Morphing method to be determined"]
    aiMorphingMethod_UNKNOWN = 0,
    #[doc = " Interpolation between morph targets"]
    aiMorphingMethod_VERTEX_BLEND = 1,
    #[doc = " Normalized morphing between morph targets"]
    aiMorphingMethod_MORPH_NORMALIZED = 2,
    #[doc = " Relative morphing between morph targets"]
    aiMorphingMethod_MORPH_RELATIVE = 3,
    _aiMorphingMethod_Force32Bit = 2147483647,
}
#[doc = " @brief A mesh represents a geometry or model with a single material.\n\n It usually consists of a number of vertices and a series of primitives/faces\n referencing the vertices. In addition there might be a series of bones, each\n of them addressing a number of vertices with a certain weight. Vertex data\n is presented in channels with each channel containing a single per-vertex\n information such as a set of texture coordinates or a normal vector.\n If a data pointer is non-null, the corresponding data stream is present.\n From C++-programs you can also use the comfort functions Has*() to\n test for the presence of various data streams.\n\n A Mesh uses only a single material which is referenced by a material ID.\n @note The mPositions member is usually not optional. However, vertex positions\n *could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in\n @code\n aiScene::mFlags\n @endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMesh {
    #[doc = " Bitwise combination of the members of the #aiPrimitiveType enum.\n This specifies which types of primitives are present in the mesh.\n The \"SortByPrimitiveType\"-Step can be used to make sure the\n output meshes consist of one primitive type each."]
    pub mPrimitiveTypes: ::std::os::raw::c_uint,
    #[doc = " The number of vertices in this mesh.\n This is also the size of all of the per-vertex data arrays.\n The maximum value for this member is #AI_MAX_VERTICES."]
    pub mNumVertices: ::std::os::raw::c_uint,
    #[doc = " The number of primitives (triangles, polygons, lines) in this  mesh.\n This is also the size of the mFaces array.\n The maximum value for this member is #AI_MAX_FACES."]
    pub mNumFaces: ::std::os::raw::c_uint,
    #[doc = " @brief Vertex positions.\n\n This array is always present in a mesh. The array is\n mNumVertices in size."]
    pub mVertices: *mut aiVector3D,
    #[doc = " @brief Vertex normals.\n\n The array contains normalized vectors, nullptr if not present.\n The array is mNumVertices in size. Normals are undefined for\n point and line primitives. A mesh consisting of points and\n lines only may not have normal vectors. Meshes with mixed\n primitive types (i.e. lines and triangles) may have normals,\n but the normals for vertices that are only referenced by\n point or line primitives are undefined and set to QNaN (WARN:\n qNaN compares to inequal to *everything*, even to qNaN itself.\n Using code like this to check whether a field is qnan is:\n @code\n #define IS_QNAN(f) (f != f)\n @endcode\n still dangerous because even 1.f == 1.f could evaluate to false! (\n remember the subtleties of IEEE754 artithmetics). Use stuff like\n @c fpclassify instead.\n @note Normal vectors computed by Assimp are always unit-length.\n However, this needn't apply for normals that have been taken\n directly from the model file."]
    pub mNormals: *mut aiVector3D,
    #[doc = " @brief Vertex tangents.\n\n The tangent of a vertex points in the direction of the positive\n X texture axis. The array contains normalized vectors, nullptr if\n not present. The array is mNumVertices in size. A mesh consisting\n of points and lines only may not have normal vectors. Meshes with\n mixed primitive types (i.e. lines and triangles) may have\n normals, but the normals for vertices that are only referenced by\n point or line primitives are undefined and set to qNaN.  See\n the #mNormals member for a detailed discussion of qNaNs.\n @note If the mesh contains tangents, it automatically also\n contains bitangents."]
    pub mTangents: *mut aiVector3D,
    #[doc = " @brief Vertex bitangents.\n\n The bitangent of a vertex points in the direction of the positive\n Y texture axis. The array contains normalized vectors, nullptr if not\n present. The array is mNumVertices in size.\n @note If the mesh contains tangents, it automatically also contains\n bitangents."]
    pub mBitangents: *mut aiVector3D,
    #[doc = " @brief Vertex color sets.\n\n A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex\n colors per vertex. nullptr if not present. Each array is\n mNumVertices in size if present."]
    pub mColors: [*mut aiColor4D; 8usize],
    #[doc = " @brief Vertex texture coordinates, also known as UV channels.\n\n A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS channels per\n vertex. Used and unused (nullptr) channels may go in any order.\n The array is mNumVertices in size."]
    pub mTextureCoords: [*mut aiVector3D; 8usize],
    #[doc = " @brief Specifies the number of components for a given UV channel.\n\n Up to three channels are supported (UVW, for accessing volume\n or cube maps). If the value is 2 for a given channel n, the\n component p.z of mTextureCoords[n][p] is set to 0.0f.\n If the value is 1 for a given channel, p.y is set to 0.0f, too.\n @note 4D coordinates are not supported"]
    pub mNumUVComponents: [::std::os::raw::c_uint; 8usize],
    #[doc = " @brief The faces the mesh is constructed from.\n\n Each face refers to a number of vertices by their indices.\n This array is always present in a mesh, its size is given\n  in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT\n is NOT set each face references an unique set of vertices."]
    pub mFaces: *mut aiFace,
    #[doc = " The number of bones this mesh contains. Can be 0, in which case the mBones array is nullptr."]
    pub mNumBones: ::std::os::raw::c_uint,
    #[doc = " @brief The bones of this mesh.\n\n A bone consists of a name by which it can be found in the\n frame hierarchy and a set of vertex weights."]
    pub mBones: *mut *mut aiBone,
    #[doc = " @brief The material used by this mesh.\n\n A mesh uses only a single material. If an imported model uses\n multiple materials, the import splits up the mesh. Use this value\n as index into the scene's material list."]
    pub mMaterialIndex: ::std::os::raw::c_uint,
    #[doc = "  Name of the mesh. Meshes can be named, but this is not a\n  requirement and leaving this field empty is totally fine.\n  There are mainly three uses for mesh names:\n   - some formats name nodes and meshes independently.\n   - importers tend to split meshes up to meet the\n      one-material-per-mesh requirement. Assigning\n      the same (dummy) name to each of the result meshes\n      aids the caller at recovering the original mesh\n      partitioning.\n   - Vertex animations refer to meshes by their names."]
    pub mName: aiString,
    #[doc = " The number of attachment meshes.\n Currently known to work with loaders:\n - Collada\n - gltf"]
    pub mNumAnimMeshes: ::std::os::raw::c_uint,
    #[doc = " Attachment meshes for this mesh, for vertex-based animation.\n Attachment meshes carry replacement data for some of the\n mesh'es vertex components (usually positions, normals).\n Currently known to work with loaders:\n - Collada\n - gltf"]
    pub mAnimMeshes: *mut *mut aiAnimMesh,
    #[doc = "  Method of morphing when anim-meshes are specified.\n  @see aiMorphingMethod to learn more about the provided morphing targets."]
    pub mMethod: aiMorphingMethod,
    #[doc = "  The bounding box."]
    pub mAABB: aiAABB,
    #[doc = " Vertex UV stream names. Pointer to array of size AI_MAX_NUMBER_OF_TEXTURECOORDS"]
    pub mTextureCoordsNames: *mut *mut aiString,
}
impl Default for aiMesh {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  A skeleton bone represents a single bone is a skeleton structure.\n\n Skeleton-Animations can be represented via a skeleton struct, which describes\n a hierarchical tree assembled from skeleton bones. A bone is linked to a mesh.\n The bone knows its parent bone. If there is no parent bone the parent id is\n marked with -1.\n The skeleton-bone stores a pointer to its used armature. If there is no\n armature this value if set to nullptr.\n A skeleton bone stores its offset-matrix, which is the absolute transformation\n for the bone. The bone stores the locale transformation to its parent as well.\n You can compute the offset matrix by multiplying the hierarchy like:\n Tree: s1 -> s2 -> s3\n Offset-Matrix s3 = locale-s3 * locale-s2 * locale-s1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiSkeletonBone {
    #[doc = " The parent bone index, is -1 one if this bone represents the root bone."]
    pub mParent: ::std::os::raw::c_int,
    #[doc = " @brief The bone armature node - used for skeleton conversion\n you must enable aiProcess_PopulateArmatureData to populate this"]
    pub mArmature: *mut aiNode,
    #[doc = " @brief The bone node in the scene - used for skeleton conversion\n you must enable aiProcess_PopulateArmatureData to populate this"]
    pub mNode: *mut aiNode,
    #[doc = " @brief The number of weights"]
    pub mNumnWeights: ::std::os::raw::c_uint,
    #[doc = " The mesh index, which will get influenced by the weight."]
    pub mMeshId: *mut aiMesh,
    #[doc = " The influence weights of this bone, by vertex index."]
    pub mWeights: *mut aiVertexWeight,
    #[doc = " Matrix that transforms from bone space to mesh space in bind pose.\n\n This matrix describes the position of the mesh\n in the local space of this bone when the skeleton was bound.\n Thus it can be used directly to determine a desired vertex position,\n given the world-space transform of the bone when animated,\n and the position of the vertex in mesh space.\n\n It is sometimes called an inverse-bind matrix,\n or inverse bind pose matrix."]
    pub mOffsetMatrix: aiMatrix4x4,
    #[doc = " Matrix that transforms the locale bone in bind pose."]
    pub mLocalMatrix: aiMatrix4x4,
}
impl Default for aiSkeletonBone {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A skeleton represents the bone hierarchy of an animation.\n\n Skeleton animations can be described as a tree of bones:\n                  root\n                    |\n                  node1\n                  /   \\\n               node3  node4\n If you want to calculate the transformation of node three you need to compute the\n transformation hierarchy for the transformation chain of node3:\n root->node1->node3\n Each node is represented as a skeleton instance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiSkeleton {
    #[doc = "  @brief The name of the skeleton instance."]
    pub mName: aiString,
    #[doc = "  @brief  The number of bones in the skeleton."]
    pub mNumBones: ::std::os::raw::c_uint,
    #[doc = "  @brief The bone instance in the skeleton."]
    pub mBones: *mut *mut aiSkeletonBone,
}
impl Default for aiSkeleton {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " Enumerates all supported types of light sources."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiLightSourceType {
    aiLightSource_UNDEFINED = 0,
    #[doc = "! A directional light source has a well-defined direction\n! but is infinitely far away. That's quite a good\n! approximation for sun light."]
    aiLightSource_DIRECTIONAL = 1,
    #[doc = "! A point light source has a well-defined position\n! in space but no direction - it emits light in all\n! directions. A normal bulb is a point light."]
    aiLightSource_POINT = 2,
    #[doc = "! A spot light source emits light in a specific\n! angle. It has a position and a direction it is pointing to.\n! A good example for a spot light is a light spot in\n! sport arenas."]
    aiLightSource_SPOT = 3,
    #[doc = "! The generic light level of the world, including the bounces\n! of all other light sources.\n! Typically, there's at most one ambient light in a scene.\n! This light type doesn't have a valid position, direction, or\n! other properties, just a color."]
    aiLightSource_AMBIENT = 4,
    #[doc = "! An area light is a rectangle with predefined size that uniformly\n! emits light from one of its sides. The position is center of the\n! rectangle and direction is its normal vector."]
    aiLightSource_AREA = 5,
    _aiLightSource_Force32Bit = 2147483647,
}
#[doc = " Helper structure to describe a light source.\n\n  Assimp supports multiple sorts of light sources, including\n  directional, point and spot lights. All of them are defined with just\n  a single structure and distinguished by their parameters.\n  Note - some file formats (such as 3DS, ASE) export a \"target point\" -\n  the point a spot light is looking at (it can even be animated). Assimp\n  writes the target point as a sub-node of a spot-lights's main node,\n  called \"<spotName>.Target\". However, this is just additional information\n  then, the transformation tracks of the main node make the\n  spot light already point in the right direction."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiLight {
    #[doc = " The name of the light source.\n\n  There must be a node in the scene-graph with the same name.\n  This node specifies the position of the light in the scene\n  hierarchy and can be animated."]
    pub mName: aiString,
    #[doc = " The type of the light source.\n\n aiLightSource_UNDEFINED is not a valid value for this member."]
    pub mType: aiLightSourceType,
    #[doc = " Position of the light source in space. Relative to the\n  transformation of the node corresponding to the light.\n\n  The position is undefined for directional lights."]
    pub mPosition: aiVector3D,
    #[doc = " Direction of the light source in space. Relative to the\n  transformation of the node corresponding to the light.\n\n  The direction is undefined for point lights. The vector\n  may be normalized, but it needn't."]
    pub mDirection: aiVector3D,
    #[doc = " Up direction of the light source in space. Relative to the\n  transformation of the node corresponding to the light.\n\n  The direction is undefined for point lights. The vector\n  may be normalized, but it needn't."]
    pub mUp: aiVector3D,
    #[doc = " Constant light attenuation factor.\n\n  The intensity of the light source at a given distance 'd' from\n  the light's position is\n  @code\n  Atten = 1/( att0 + att1 * d + att2 * d*d)\n  @endcode\n  This member corresponds to the att0 variable in the equation.\n  Naturally undefined for directional lights."]
    pub mAttenuationConstant: f32,
    #[doc = " Linear light attenuation factor.\n\n  The intensity of the light source at a given distance 'd' from\n  the light's position is\n  @code\n  Atten = 1/( att0 + att1 * d + att2 * d*d)\n  @endcode\n  This member corresponds to the att1 variable in the equation.\n  Naturally undefined for directional lights."]
    pub mAttenuationLinear: f32,
    #[doc = " Quadratic light attenuation factor.\n\n  The intensity of the light source at a given distance 'd' from\n  the light's position is\n  @code\n  Atten = 1/( att0 + att1 * d + att2 * d*d)\n  @endcode\n  This member corresponds to the att2 variable in the equation.\n  Naturally undefined for directional lights."]
    pub mAttenuationQuadratic: f32,
    #[doc = " Diffuse color of the light source\n\n  The diffuse light color is multiplied with the diffuse\n  material color to obtain the final color that contributes\n  to the diffuse shading term."]
    pub mColorDiffuse: aiColor3D,
    #[doc = " Specular color of the light source\n\n  The specular light color is multiplied with the specular\n  material color to obtain the final color that contributes\n  to the specular shading term."]
    pub mColorSpecular: aiColor3D,
    #[doc = " Ambient color of the light source\n\n  The ambient light color is multiplied with the ambient\n  material color to obtain the final color that contributes\n  to the ambient shading term. Most renderers will ignore\n  this value it, is just a remaining of the fixed-function pipeline\n  that is still supported by quite many file formats."]
    pub mColorAmbient: aiColor3D,
    #[doc = " Inner angle of a spot light's light cone.\n\n  The spot light has maximum influence on objects inside this\n  angle. The angle is given in radians. It is 2PI for point\n  lights and undefined for directional lights."]
    pub mAngleInnerCone: f32,
    #[doc = " Outer angle of a spot light's light cone.\n\n  The spot light does not affect objects outside this angle.\n  The angle is given in radians. It is 2PI for point lights and\n  undefined for directional lights. The outer angle must be\n  greater than or equal to the inner angle.\n  It is assumed that the application uses a smooth\n  interpolation between the inner and the outer cone of the\n  spot light."]
    pub mAngleOuterCone: f32,
    #[doc = " Size of area light source."]
    pub mSize: aiVector2D,
}
impl Default for aiLight {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Helper structure to describe a virtual camera.\n\n Cameras have a representation in the node graph and can be animated.\n An important aspect is that the camera itself is also part of the\n scene-graph. This means, any values such as the look-at vector are not\n *absolute*, they're <b>relative</b> to the coordinate system defined\n by the node which corresponds to the camera. This allows for camera\n animations. For static cameras parameters like the 'look-at' or 'up' vectors\n are usually specified directly in aiCamera, but beware, they could also\n be encoded in the node transformation. The following (pseudo)code sample\n shows how to do it: <br><br>\n @code\n // Get the camera matrix for a camera at a specific time\n // if the node hierarchy for the camera does not contain\n // at least one animated node this is a static computation\n get-camera-matrix (node sceneRoot, camera cam) : matrix\n {\n    node   cnd = find-node-for-camera(cam)\n    matrix cmt = identity()\n\n    // as usual - get the absolute camera transformation for this frame\n    for each node nd in hierarchy from sceneRoot to cnd\n      matrix cur\n      if (is-animated(nd))\n         cur = eval-animation(nd)\n      else cur = nd->mTransformation;\n      cmt = mult-matrices( cmt, cur )\n    end for\n\n    // now multiply with the camera's own local transform\n    cam = mult-matrices (cam, get-camera-matrix(cmt) )\n }\n @endcode\n\n @note some file formats (such as 3DS, ASE) export a \"target point\" -\n the point the camera is looking at (it can even be animated). Assimp\n writes the target point as a subnode of the camera's main node,\n called \"<camName>.Target\". However this is just additional information\n then the transformation tracks of the camera main node make the\n camera already look in the right direction."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiCamera {
    #[doc = " The name of the camera.\n\n  There must be a node in the scenegraph with the same name.\n  This node specifies the position of the camera in the scene\n  hierarchy and can be animated."]
    pub mName: aiString,
    #[doc = " Position of the camera relative to the coordinate space\n  defined by the corresponding node.\n\n  The default value is 0|0|0."]
    pub mPosition: aiVector3D,
    #[doc = " 'Up' - vector of the camera coordinate system relative to\n  the coordinate space defined by the corresponding node.\n\n  The 'right' vector of the camera coordinate system is\n  the cross product of  the up and lookAt vectors.\n  The default value is 0|1|0. The vector\n  may be normalized, but it needn't."]
    pub mUp: aiVector3D,
    #[doc = " 'LookAt' - vector of the camera coordinate system relative to\n  the coordinate space defined by the corresponding node.\n\n  This is the viewing direction of the user.\n  The default value is 0|0|1. The vector\n  may be normalized, but it needn't."]
    pub mLookAt: aiVector3D,
    #[doc = " Horizontal field of view angle, in radians.\n\n  The field of view angle is the angle between the center\n  line of the screen and the left or right border.\n  The default value is 1/4PI."]
    pub mHorizontalFOV: f32,
    #[doc = " Distance of the near clipping plane from the camera.\n\n The value may not be 0.f (for arithmetic reasons to prevent\n a division through zero). The default value is 0.1f."]
    pub mClipPlaneNear: f32,
    #[doc = " Distance of the far clipping plane from the camera.\n\n The far clipping plane must, of course, be further away than the\n near clipping plane. The default value is 1000.f. The ratio\n between the near and the far plane should not be too\n large (between 1000-10000 should be ok) to avoid floating-point\n inaccuracies which could lead to z-fighting."]
    pub mClipPlaneFar: f32,
    #[doc = " Screen aspect ratio.\n\n This is the ration between the width and the height of the\n screen. Typical values are 4/3, 1/2 or 1/1. This value is\n 0 if the aspect ratio is not defined in the source file.\n 0 is also the default value."]
    pub mAspect: f32,
    #[doc = " Half horizontal orthographic width, in scene units.\n\n  The orthographic width specifies the half width of the\n  orthographic view box. If non-zero the camera is\n  orthographic and the mAspect should define to the\n  ratio between the orthographic width and height\n  and mHorizontalFOV should be set to 0.\n  The default value is 0 (not orthographic)."]
    pub mOrthographicWidth: f32,
}
impl Default for aiCamera {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " @brief Defines how the Nth texture of a specific type is combined with\n  the result of all previous layers.\n\n  Example (left: key, right: value): <br>\n  @code\n  DiffColor0     - gray\n  DiffTextureOp0 - aiTextureOpMultiply\n  DiffTexture0   - tex1.png\n  DiffTextureOp0 - aiTextureOpAdd\n  DiffTexture1   - tex2.png\n  @endcode\n  Written as equation, the final diffuse term for a specific pixel would be:\n  @code\n  diffFinal = DiffColor0 * sampleTex(DiffTexture0,UV0) +\n     sampleTex(DiffTexture1,UV0) * diffContrib;\n  @endcode\n  where 'diffContrib' is the intensity of the incoming light for that pixel."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiTextureOp {
    #[doc = " T = T1 * T2"]
    aiTextureOp_Multiply = 0,
    #[doc = " T = T1 + T2"]
    aiTextureOp_Add = 1,
    #[doc = " T = T1 - T2"]
    aiTextureOp_Subtract = 2,
    #[doc = " T = T1 / T2"]
    aiTextureOp_Divide = 3,
    #[doc = " T = (T1 + T2) - (T1 * T2)"]
    aiTextureOp_SmoothAdd = 4,
    #[doc = " T = T1 + (T2-0.5)"]
    aiTextureOp_SignedAdd = 5,
    _aiTextureOp_Force32Bit = 2147483647,
}
#[repr(i32)]
#[doc = " @brief Defines how UV coordinates outside the [0...1] range are handled.\n\n  Commonly referred to as 'wrapping mode'."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiTextureMapMode {
    #[doc = " A texture coordinate u|v is translated to u%1|v%1"]
    aiTextureMapMode_Wrap = 0,
    #[doc = " Texture coordinates outside [0...1]\n  are clamped to the nearest valid value."]
    aiTextureMapMode_Clamp = 1,
    #[doc = " If the texture coordinates for a pixel are outside [0...1]\n  the texture is not applied to that pixel"]
    aiTextureMapMode_Decal = 3,
    #[doc = " A texture coordinate u|v becomes u%1|v%1 if (u-(u%1))%2 is zero and\n  1-(u%1)|1-(v%1) otherwise"]
    aiTextureMapMode_Mirror = 2,
    _aiTextureMapMode_Force32Bit = 2147483647,
}
#[repr(i32)]
#[doc = " @brief Defines how the mapping coords for a texture are generated.\n\n  Real-time applications typically require full UV coordinates, so the use of\n  the aiProcess_GenUVCoords step is highly recommended. It generates proper\n  UV channels for non-UV mapped objects, as long as an accurate description\n  how the mapping should look like (e.g spherical) is given.\n  See the #AI_MATKEY_MAPPING property for more details."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiTextureMapping {
    #[doc = " The mapping coordinates are taken from an UV channel.\n\n  #AI_MATKEY_UVWSRC property specifies from which UV channel\n  the texture coordinates are to be taken from (remember,\n  meshes can have more than one UV channel)."]
    aiTextureMapping_UV = 0,
    #[doc = " Spherical mapping"]
    aiTextureMapping_SPHERE = 1,
    #[doc = " Cylindrical mapping"]
    aiTextureMapping_CYLINDER = 2,
    #[doc = " Cubic mapping"]
    aiTextureMapping_BOX = 3,
    #[doc = " Planar mapping"]
    aiTextureMapping_PLANE = 4,
    #[doc = " Undefined mapping. Have fun."]
    aiTextureMapping_OTHER = 5,
    _aiTextureMapping_Force32Bit = 2147483647,
}
#[repr(i32)]
#[doc = " @brief Defines the purpose of a texture\n\n  This is a very difficult topic. Different 3D packages support different\n  kinds of textures. For very common texture types, such as bumpmaps, the\n  rendering results depend on implementation details in the rendering\n  pipelines of these applications. Assimp loads all texture references from\n  the model file and tries to determine which of the predefined texture\n  types below is the best choice to match the original use of the texture\n  as closely as possible.<br>\n\n  In content pipelines you'll usually define how textures have to be handled,\n  and the artists working on models have to conform to this specification,\n  regardless which 3D tool they're using."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiTextureType {
    #[doc = " Dummy value.\n\n  No texture, but the value to be used as 'texture semantic'\n  (#aiMaterialProperty::mSemantic) for all material properties\n  *not* related to textures."]
    aiTextureType_NONE = 0,
    #[doc = " The texture is combined with the result of the diffuse\n  lighting equation.\n  OR\n  PBR Specular/Glossiness"]
    aiTextureType_DIFFUSE = 1,
    #[doc = " The texture is combined with the result of the specular\n  lighting equation.\n  OR\n  PBR Specular/Glossiness"]
    aiTextureType_SPECULAR = 2,
    #[doc = " The texture is combined with the result of the ambient\n  lighting equation."]
    aiTextureType_AMBIENT = 3,
    #[doc = " The texture is added to the result of the lighting\n  calculation. It isn't influenced by incoming light."]
    aiTextureType_EMISSIVE = 4,
    #[doc = " The texture is a height map.\n\n  By convention, higher gray-scale values stand for\n  higher elevations from the base height."]
    aiTextureType_HEIGHT = 5,
    #[doc = " The texture is a (tangent space) normal-map.\n\n  Again, there are several conventions for tangent-space\n  normal maps. Assimp does (intentionally) not\n  distinguish here."]
    aiTextureType_NORMALS = 6,
    #[doc = " The texture defines the glossiness of the material.\n\n  The glossiness is in fact the exponent of the specular\n  (phong) lighting equation. Usually there is a conversion\n  function defined to map the linear color values in the\n  texture to a suitable exponent. Have fun."]
    aiTextureType_SHININESS = 7,
    #[doc = " The texture defines per-pixel opacity.\n\n  Usually 'white' means opaque and 'black' means\n  'transparency'. Or quite the opposite. Have fun."]
    aiTextureType_OPACITY = 8,
    #[doc = " Displacement texture\n\n  The exact purpose and format is application-dependent.\n  Higher color values stand for higher vertex displacements."]
    aiTextureType_DISPLACEMENT = 9,
    #[doc = " Lightmap texture (aka Ambient Occlusion)\n\n  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n  covered by this material property. The texture contains a\n  scaling value for the final color value of a pixel. Its\n  intensity is not affected by incoming light."]
    aiTextureType_LIGHTMAP = 10,
    #[doc = " Reflection texture\n\n Contains the color of a perfect mirror reflection.\n Rarely used, almost never for real-time applications."]
    aiTextureType_REFLECTION = 11,
    #[doc = " PBR Materials\n PBR definitions from maya and other modelling packages now use this standard.\n This was originally introduced around 2012.\n Support for this is in game engines like Godot, Unreal or Unity3D.\n Modelling packages which use this are very common now."]
    aiTextureType_BASE_COLOR = 12,
    #[doc = " PBR Materials\n PBR definitions from maya and other modelling packages now use this standard.\n This was originally introduced around 2012.\n Support for this is in game engines like Godot, Unreal or Unity3D.\n Modelling packages which use this are very common now."]
    aiTextureType_NORMAL_CAMERA = 13,
    #[doc = " PBR Materials\n PBR definitions from maya and other modelling packages now use this standard.\n This was originally introduced around 2012.\n Support for this is in game engines like Godot, Unreal or Unity3D.\n Modelling packages which use this are very common now."]
    aiTextureType_EMISSION_COLOR = 14,
    #[doc = " PBR Materials\n PBR definitions from maya and other modelling packages now use this standard.\n This was originally introduced around 2012.\n Support for this is in game engines like Godot, Unreal or Unity3D.\n Modelling packages which use this are very common now."]
    aiTextureType_METALNESS = 15,
    #[doc = " PBR Materials\n PBR definitions from maya and other modelling packages now use this standard.\n This was originally introduced around 2012.\n Support for this is in game engines like Godot, Unreal or Unity3D.\n Modelling packages which use this are very common now."]
    aiTextureType_DIFFUSE_ROUGHNESS = 16,
    #[doc = " PBR Materials\n PBR definitions from maya and other modelling packages now use this standard.\n This was originally introduced around 2012.\n Support for this is in game engines like Godot, Unreal or Unity3D.\n Modelling packages which use this are very common now."]
    aiTextureType_AMBIENT_OCCLUSION = 17,
    #[doc = " Unknown texture\n\n  A texture reference that does not match any of the definitions\n  above is considered to be 'unknown'. It is still imported,\n  but is excluded from any further post-processing."]
    aiTextureType_UNKNOWN = 18,
    #[doc = " Sheen\n Generally used to simulate textiles that are covered in a layer of microfibers\n eg velvet\n https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen"]
    aiTextureType_SHEEN = 19,
    #[doc = " Clearcoat\n Simulates a layer of 'polish' or 'lacquer' layered on top of a PBR substrate\n https://autodesk.github.io/standard-surface/#closures/coating\n https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat"]
    aiTextureType_CLEARCOAT = 20,
    #[doc = " Transmission\n Simulates transmission through the surface\n May include further information such as wall thickness"]
    aiTextureType_TRANSMISSION = 21,
    #[doc = " Maya material declarations"]
    aiTextureType_MAYA_BASE = 22,
    #[doc = " Maya material declarations"]
    aiTextureType_MAYA_SPECULAR = 23,
    #[doc = " Maya material declarations"]
    aiTextureType_MAYA_SPECULAR_COLOR = 24,
    #[doc = " Maya material declarations"]
    aiTextureType_MAYA_SPECULAR_ROUGHNESS = 25,
    #[doc = " Anisotropy\n Simulates a surface with directional properties"]
    aiTextureType_ANISOTROPY = 26,
    #[doc = " gltf material declarations\n Refs: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#metallic-roughness-material\n           \"textures for metalness and roughness properties are packed together in a single\n           texture called metallicRoughnessTexture. Its green channel contains roughness\n           values and its blue channel contains metalness values...\"\n       https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_material_pbrmetallicroughness_metallicroughnesstexture\n           \"The metalness values are sampled from the B channel. The roughness values are\n           sampled from the G channel...\""]
    aiTextureType_GLTF_METALLIC_ROUGHNESS = 27,
    _aiTextureType_Force32Bit = 2147483647,
}
unsafe extern "C" {
    #[doc = " @brief  Get a string for a given aiTextureType\n\n @param  in  The texture type\n @return The description string for the texture type."]
    pub fn aiTextureTypeToString(in_: aiTextureType) -> *const ::std::os::raw::c_char;
}
impl aiShadingMode {
    pub const aiShadingMode_Unlit: aiShadingMode = aiShadingMode::aiShadingMode_NoShading;
}
#[repr(i32)]
#[doc = " @brief Defines all shading models supported by the library\n\n  Property: #AI_MATKEY_SHADING_MODEL\n\n  The list of shading modes has been taken from Blender.\n  See Blender documentation for more information. The API does\n  not distinguish between \"specular\" and \"diffuse\" shaders (thus the\n  specular term for diffuse shading models like Oren-Nayar remains\n  undefined). <br>\n  Again, this value is just a hint. Assimp tries to select the shader whose\n  most common implementation matches the original rendering results of the\n  3D modeler which wrote a particular model as closely as possible.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiShadingMode {
    #[doc = " Flat shading. Shading is done on per-face base,\n  diffuse only. Also known as 'faceted shading'."]
    aiShadingMode_Flat = 1,
    #[doc = " Simple Gouraud shading."]
    aiShadingMode_Gouraud = 2,
    #[doc = " Phong-Shading -"]
    aiShadingMode_Phong = 3,
    #[doc = " Phong-Blinn-Shading"]
    aiShadingMode_Blinn = 4,
    #[doc = " Toon-Shading per pixel\n\n  Also known as 'comic' shader."]
    aiShadingMode_Toon = 5,
    #[doc = " OrenNayar-Shading per pixel\n\n  Extension to standard Lambertian shading, taking the\n  roughness of the material into account"]
    aiShadingMode_OrenNayar = 6,
    #[doc = " Minnaert-Shading per pixel\n\n  Extension to standard Lambertian shading, taking the\n  \"darkness\" of the material into account"]
    aiShadingMode_Minnaert = 7,
    #[doc = " CookTorrance-Shading per pixel\n\n  Special shader for metallic surfaces."]
    aiShadingMode_CookTorrance = 8,
    #[doc = " No shading at all. Constant light influence of 1.0.\n Also known as \"Unlit\""]
    aiShadingMode_NoShading = 9,
    #[doc = " Fresnel shading"]
    aiShadingMode_Fresnel = 10,
    #[doc = " Physically-Based Rendering (PBR) shading using\n Bidirectional scattering/reflectance distribution function (BSDF/BRDF)\n There are multiple methods under this banner, and model files may provide\n data for more than one PBR-BRDF method.\n Applications should use the set of provided properties to determine which\n of their preferred PBR rendering methods are likely to be available\n eg:\n - If AI_MATKEY_METALLIC_FACTOR is set, then a Metallic/Roughness is available\n - If AI_MATKEY_GLOSSINESS_FACTOR is set, then a Specular/Glossiness is available\n Note that some PBR methods allow layering of techniques"]
    aiShadingMode_PBR_BRDF = 11,
    _aiShadingMode_Force32Bit = 2147483647,
}
pub mod aiTextureFlags {
    #[doc = "  @brief Defines some mixed flags for a particular texture.\n\n  Usually you'll instruct your cg artists how textures have to look like ...\n  and how they will be processed in your application. However, if you use\n  Assimp for completely generic loading purposes you might also need to\n  process these flags in order to display as many 'unknown' 3D models as\n  possible correctly.\n\n  This corresponds to the #AI_MATKEY_TEXFLAGS property."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = " The texture's color values have to be inverted (component-wise 1-n)"]
    pub const aiTextureFlags_Invert: Type = 1;
    #[doc = " Explicit request to the application to process the alpha channel\n  of the texture.\n\n  Mutually exclusive with #aiTextureFlags_IgnoreAlpha. These\n  flags are set if the library can say for sure that the alpha\n  channel is used/is not used. If the model format does not\n  define this, it is left to the application to decide whether\n  the texture alpha channel - if any - is evaluated or not."]
    pub const aiTextureFlags_UseAlpha: Type = 2;
    #[doc = " Explicit request to the application to ignore the alpha channel\n  of the texture.\n\n  Mutually exclusive with #aiTextureFlags_UseAlpha."]
    pub const aiTextureFlags_IgnoreAlpha: Type = 4;
    pub const _aiTextureFlags_Force32Bit: Type = 2147483647;
}
#[repr(i32)]
#[doc = "  @brief Defines alpha-blend flags.\n\n  If you're familiar with OpenGL or D3D, these flags aren't new to you.\n  They define *how* the final color value of a pixel is computed, basing\n  on the previous color at that pixel and the new color value from the\n  material.\n  The blend formula is:\n  @code\n    SourceColor * SourceBlend + DestColor * DestBlend\n  @endcode\n  where DestColor is the previous color in the frame-buffer at this\n  position and SourceColor is the material color before the transparency\n  calculation.<br>\n  This corresponds to the #AI_MATKEY_BLEND_FUNC property."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiBlendMode {
    #[doc = "  Formula:\n  @code\n  SourceColor*SourceAlpha + DestColor*(1-SourceAlpha)\n  @endcode"]
    aiBlendMode_Default = 0,
    #[doc = " Additive blending\n\n  Formula:\n  @code\n  SourceColor*1 + DestColor*1\n  @endcode"]
    aiBlendMode_Additive = 1,
    _aiBlendMode_Force32Bit = 2147483647,
}
#[doc = "  @brief Defines how an UV channel is transformed.\n\n  This is just a helper structure for the #AI_MATKEY_UVTRANSFORM key.\n  See its documentation for more details.\n\n  Typically you'll want to build a matrix of this information. However,\n  we keep separate scaling/translation/rotation values to make it\n  easier to process and optimize UV transformations internally."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiUVTransform {
    #[doc = " Translation on the u and v axes.\n\n  The default value is (0|0)."]
    pub mTranslation: aiVector2D,
    #[doc = " Scaling on the u and v axes.\n\n  The default value is (1|1)."]
    pub mScaling: aiVector2D,
    #[doc = " Rotation - in counter-clockwise direction.\n\n  The rotation angle is specified in radians. The\n  rotation center is 0.5f|0.5f. The default value\n  0.f."]
    pub mRotation: ai_real,
}
#[repr(i32)]
#[doc = "  @brief A very primitive RTTI system for the contents of material properties."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiPropertyTypeInfo {
    #[doc = " Array of single-precision (32 Bit) floats\n\n  It is possible to use aiGetMaterialInteger[Array]() (or the C++-API\n  aiMaterial::Get()) to query properties stored in floating-point format.\n  The material system performs the type conversion automatically."]
    aiPTI_Float = 1,
    #[doc = " Array of double-precision (64 Bit) floats\n\n  It is possible to use aiGetMaterialInteger[Array]() (or the C++-API\n  aiMaterial::Get()) to query properties stored in floating-point format.\n  The material system performs the type conversion automatically."]
    aiPTI_Double = 2,
    #[doc = " The material property is an aiString.\n\n  Arrays of strings aren't possible, aiGetMaterialString() (or the\n  C++-API aiMaterial::Get()) *must* be used to query a string property."]
    aiPTI_String = 3,
    #[doc = " Array of (32 Bit) integers\n\n  It is possible to use aiGetMaterialFloat[Array]() (or the C++-API\n  aiMaterial::Get()) to query properties stored in integer format.\n  The material system performs the type conversion automatically."]
    aiPTI_Integer = 4,
    #[doc = " Simple binary buffer, content undefined. Not convertible to anything."]
    aiPTI_Buffer = 5,
    _aiPTI_Force32Bit = 2147483647,
}
#[doc = " @brief Data structure for a single material property\n\n  As an user, you'll probably never need to deal with this data structure.\n  Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family\n  of functions to query material properties easily. Processing them\n  manually is faster, but it is not the recommended way. It isn't worth\n  the effort. <br>\n  Material property names follow a simple scheme:\n  @code\n    $<name>\n    ?<name>\n       A public property, there must be corresponding AI_MATKEY_XXX define\n       2nd: Public, but ignored by the #aiProcess_RemoveRedundantMaterials\n       post-processing step.\n    ~<name>\n       A temporary property for internal use.\n  @endcode\n  @see aiMaterial"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMaterialProperty {
    #[doc = " Specifies the name of the property (key)\n  Keys are generally case insensitive."]
    pub mKey: aiString,
    #[doc = " Textures: Specifies their exact usage semantic.\n For non-texture properties, this member is always 0\n (or, better-said, #aiTextureType_NONE)."]
    pub mSemantic: ::std::os::raw::c_uint,
    #[doc = " Textures: Specifies the index of the texture.\n  For non-texture properties, this member is always 0."]
    pub mIndex: ::std::os::raw::c_uint,
    #[doc = " Size of the buffer mData is pointing to, in bytes.\n  This value may not be 0."]
    pub mDataLength: ::std::os::raw::c_uint,
    #[doc = " Type information for the property.\n\n Defines the data layout inside the data buffer. This is used\n by the library internally to perform debug checks and to\n utilize proper type conversions.\n (It's probably a hacky solution, but it works.)"]
    pub mType: aiPropertyTypeInfo,
    #[doc = " Binary buffer to hold the property's value.\n The size of the buffer is always mDataLength."]
    pub mData: *mut ::std::os::raw::c_char,
}
impl Default for aiMaterialProperty {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMaterial {
    #[doc = " List of all material properties loaded."]
    pub mProperties: *mut *mut aiMaterialProperty,
    #[doc = " Number of properties in the data base"]
    pub mNumProperties: ::std::os::raw::c_uint,
    #[doc = " Storage allocated"]
    pub mNumAllocated: ::std::os::raw::c_uint,
}
impl Default for aiMaterial {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " @brief Retrieve a material property with a specific key from the material\n\n @param pMat Pointer to the input material. May not be NULL\n @param pKey Key to search for. One of the AI_MATKEY_XXX constants.\n @param type Specifies the type of the texture to be retrieved (\n    e.g. diffuse, specular, height map ...)\n @param index Index of the texture to be retrieved.\n @param pPropOut Pointer to receive a pointer to a valid aiMaterialProperty\n        structure or NULL if the key has not been found."]
    pub fn aiGetMaterialProperty(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pPropOut: *mut *const aiMaterialProperty,
    ) -> aiReturn;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve an array of float values with a specific key\n  from the material\n\n Pass one of the AI_MATKEY_XXX constants for the last three parameters (the\n example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)\n @code\n aiUVTransform trafo;\n unsigned int max = sizeof(aiUVTransform);\n if (AI_SUCCESS != aiGetMaterialFloatArray(mat, AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE,0),\n    (float*)&trafo, &max) || sizeof(aiUVTransform) != max)\n {\n   // error handling\n }\n @endcode\n\n @param pMat Pointer to the input material. May not be NULL\n @param pKey Key to search for. One of the AI_MATKEY_XXX constants.\n @param pOut Pointer to a buffer to receive the result.\n @param pMax Specifies the size of the given buffer, in float's.\n        Receives the number of values (not bytes!) read.\n @param type (see the code sample above)\n @param index (see the code sample above)\n @return Specifies whether the key has been found. If not, the output\n   arrays remains unmodified and pMax is set to 0."]
    pub fn aiGetMaterialFloatArray(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut ai_real,
        pMax: *mut ::std::os::raw::c_uint,
    ) -> aiReturn;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve an array of integer values with a specific key\n  from a material\n\n See the sample for aiGetMaterialFloatArray for more information."]
    pub fn aiGetMaterialIntegerArray(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut ::std::os::raw::c_int,
        pMax: *mut ::std::os::raw::c_uint,
    ) -> aiReturn;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve a color value from the material property table\n\n See the sample for aiGetMaterialFloat for more information"]
    pub fn aiGetMaterialColor(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut aiColor4D,
    ) -> aiReturn;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve a aiUVTransform value from the material property table\n\n See the sample for aiGetMaterialFloat for more information"]
    pub fn aiGetMaterialUVTransform(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut aiUVTransform,
    ) -> aiReturn;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve a string from the material property table\n\n See the sample for aiGetMaterialFloat for more information."]
    pub fn aiGetMaterialString(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut aiString,
    ) -> aiReturn;
}
unsafe extern "C" {
    #[doc = " Get the number of textures for a particular texture type.\n  @param[in] pMat Pointer to the input material. May not be NULL\n  @param type Texture type to check for\n  @return Number of textures for this type.\n  @note A texture can be easily queried using #aiGetMaterialTexture()"]
    pub fn aiGetMaterialTextureCount(
        pMat: *const aiMaterial,
        type_: aiTextureType,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn aiGetMaterialTexture(
        mat: *const aiMaterial,
        type_: aiTextureType,
        index: ::std::os::raw::c_uint,
        path: *mut aiString,
        mapping: *mut aiTextureMapping,
        uvindex: *mut ::std::os::raw::c_uint,
        blend: *mut ai_real,
        op: *mut aiTextureOp,
        mapmode: *mut aiTextureMapMode,
        flags: *mut ::std::os::raw::c_uint,
    ) -> aiReturn;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiAnimInterpolation {
    aiAnimInterpolation_Step = 0,
    aiAnimInterpolation_Linear = 1,
    aiAnimInterpolation_Spherical_Linear = 2,
    aiAnimInterpolation_Cubic_Spline = 3,
    _aiAnimInterpolation_Force32Bit = 2147483647,
}
#[doc = " A time-value pair specifying a certain 3D vector for the given time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiVectorKey {
    #[doc = " The time of this key"]
    pub mTime: f64,
    #[doc = " The value of this key"]
    pub mValue: aiVector3D,
    #[doc = " The interpolation setting of this key"]
    pub mInterpolation: aiAnimInterpolation,
}
impl Default for aiVectorKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A time-value pair specifying a rotation for the given time.\n  Rotations are expressed with quaternions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiQuatKey {
    #[doc = " The time of this key"]
    pub mTime: f64,
    #[doc = " The value of this key"]
    pub mValue: aiQuaternion,
    #[doc = " The interpolation setting of this key"]
    pub mInterpolation: aiAnimInterpolation,
}
impl Default for aiQuatKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Binds a anim-mesh to a specific point in time."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aiMeshKey {
    #[doc = " The time of this key"]
    pub mTime: f64,
    #[doc = " Index into the aiMesh::mAnimMeshes array of the\n  mesh corresponding to the #aiMeshAnim hosting this\n  key frame. The referenced anim mesh is evaluated\n  according to the rules defined in the docs for #aiAnimMesh."]
    pub mValue: ::std::os::raw::c_uint,
}
#[doc = " Binds a morph anim mesh to a specific point in time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMeshMorphKey {
    #[doc = " The time of this key"]
    pub mTime: f64,
    #[doc = " The values and weights at the time of this key\n   - mValues: index of attachment mesh to apply weight at the same position in mWeights\n   - mWeights: weight to apply to the blend shape index at the same position in mValues"]
    pub mValues: *mut ::std::os::raw::c_uint,
    pub mWeights: *mut f64,
    #[doc = " The number of values and weights"]
    pub mNumValuesAndWeights: ::std::os::raw::c_uint,
}
impl Default for aiMeshMorphKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " Defines how an animation channel behaves outside the defined time\n  range. This corresponds to aiNodeAnim::mPreState and\n  aiNodeAnim::mPostState."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiAnimBehaviour {
    #[doc = " The value from the default node transformation is taken"]
    aiAnimBehaviour_DEFAULT = 0,
    #[doc = " The nearest key value is used without interpolation"]
    aiAnimBehaviour_CONSTANT = 1,
    #[doc = " The value of the nearest two keys is linearly\n  extrapolated for the current time value."]
    aiAnimBehaviour_LINEAR = 2,
    #[doc = " The animation is repeated.\n\n  If the animation key go from n to m and the current\n  time is t, use the value at (t-n) % (|m-n|)."]
    aiAnimBehaviour_REPEAT = 3,
    _aiAnimBehaviour_Force32Bit = 2147483647,
}
#[doc = " Describes the animation of a single node. The name specifies the\n  bone/node which is affected by this animation channel. The keyframes\n  are given in three separate series of values, one each for position,\n  rotation and scaling. The transformation matrix computed from these\n  values replaces the node's original transformation matrix at a\n  specific time.\n  This means all keys are absolute and not relative to the bone default pose.\n  The order in which the transformations are applied is\n  - as usual - scaling, rotation, translation.\n\n  @note All keys are returned in their correct, chronological order.\n  Duplicate keys don't pass the validation step. Most likely there\n  will be no negative time values, but they are not forbidden also ( so\n  implementations need to cope with them! )"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiNodeAnim {
    #[doc = " The name of the node affected by this animation. The node\n  must exist and it must be unique."]
    pub mNodeName: aiString,
    #[doc = " The number of position keys"]
    pub mNumPositionKeys: ::std::os::raw::c_uint,
    #[doc = " The position keys of this animation channel. Positions are\n specified as 3D vector. The array is mNumPositionKeys in size.\n\n If there are position keys, there will also be at least one\n scaling and one rotation key."]
    pub mPositionKeys: *mut aiVectorKey,
    #[doc = " The number of rotation keys"]
    pub mNumRotationKeys: ::std::os::raw::c_uint,
    #[doc = " The rotation keys of this animation channel. Rotations are\n  given as quaternions,  which are 4D vectors. The array is\n  mNumRotationKeys in size.\n\n If there are rotation keys, there will also be at least one\n scaling and one position key."]
    pub mRotationKeys: *mut aiQuatKey,
    #[doc = " The number of scaling keys"]
    pub mNumScalingKeys: ::std::os::raw::c_uint,
    #[doc = " The scaling keys of this animation channel. Scalings are\n  specified as 3D vector. The array is mNumScalingKeys in size.\n\n If there are scaling keys, there will also be at least one\n position and one rotation key."]
    pub mScalingKeys: *mut aiVectorKey,
    #[doc = " Defines how the animation behaves before the first\n  key is encountered.\n\n  The default value is aiAnimBehaviour_DEFAULT (the original\n  transformation matrix of the affected node is used)."]
    pub mPreState: aiAnimBehaviour,
    #[doc = " Defines how the animation behaves after the last\n  key was processed.\n\n  The default value is aiAnimBehaviour_DEFAULT (the original\n  transformation matrix of the affected node is taken)."]
    pub mPostState: aiAnimBehaviour,
}
impl Default for aiNodeAnim {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Describes vertex-based animations for a single mesh or a group of\n  meshes. Meshes carry the animation data for each frame in their\n  aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to\n  define keyframes linking each mesh attachment to a particular\n  point in time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMeshAnim {
    #[doc = " Name of the mesh to be animated. An empty string is not allowed,\n  animated meshes need to be named (not necessarily uniquely,\n  the name can basically serve as wild-card to select a group\n  of meshes with similar animation setup)"]
    pub mName: aiString,
    #[doc = " Size of the #mKeys array. Must be 1, at least."]
    pub mNumKeys: ::std::os::raw::c_uint,
    #[doc = " Key frames of the animation. May not be nullptr."]
    pub mKeys: *mut aiMeshKey,
}
impl Default for aiMeshAnim {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Describes a morphing animation of a given mesh."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMeshMorphAnim {
    #[doc = " Name of the mesh to be animated. An empty string is not allowed,\n  animated meshes need to be named (not necessarily uniquely,\n  the name can basically serve as wildcard to select a group\n  of meshes with similar animation setup)"]
    pub mName: aiString,
    #[doc = " Size of the #mKeys array. Must be 1, at least."]
    pub mNumKeys: ::std::os::raw::c_uint,
    #[doc = " Key frames of the animation. May not be nullptr."]
    pub mKeys: *mut aiMeshMorphKey,
}
impl Default for aiMeshMorphAnim {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An animation consists of key-frame data for a number of nodes. For\n  each node affected by the animation a separate series of data is given."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiAnimation {
    #[doc = " The name of the animation. If the modeling package this data was\n  exported from does support only a single animation channel, this\n  name is usually empty (length is zero)."]
    pub mName: aiString,
    #[doc = " Duration of the animation in ticks."]
    pub mDuration: f64,
    #[doc = " Ticks per second. 0 if not specified in the imported file"]
    pub mTicksPerSecond: f64,
    #[doc = " The number of bone animation channels. Each channel affects\n  a single node."]
    pub mNumChannels: ::std::os::raw::c_uint,
    #[doc = " The node animation channels. Each channel affects a single node.\n  The array is mNumChannels in size."]
    pub mChannels: *mut *mut aiNodeAnim,
    #[doc = " The number of mesh animation channels. Each channel affects\n  a single mesh and defines vertex-based animation."]
    pub mNumMeshChannels: ::std::os::raw::c_uint,
    #[doc = " The mesh animation channels. Each channel affects a single mesh.\n  The array is mNumMeshChannels in size."]
    pub mMeshChannels: *mut *mut aiMeshAnim,
    #[doc = " The number of mesh animation channels. Each channel affects\n  a single mesh and defines morphing animation."]
    pub mNumMorphMeshChannels: ::std::os::raw::c_uint,
    #[doc = " The morph mesh animation channels. Each channel affects a single mesh.\n  The array is mNumMorphMeshChannels in size."]
    pub mMorphMeshChannels: *mut *mut aiMeshMorphAnim,
}
impl Default for aiAnimation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " Enum used to distinguish data types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiMetadataType {
    AI_BOOL = 0,
    AI_INT32 = 1,
    AI_UINT64 = 2,
    AI_FLOAT = 3,
    AI_DOUBLE = 4,
    AI_AISTRING = 5,
    AI_AIVECTOR3D = 6,
    AI_AIMETADATA = 7,
    AI_INT64 = 8,
    AI_UINT32 = 9,
    AI_META_MAX = 10,
    FORCE_32BIT = 2147483647,
}
#[doc = " Metadata entry\n\n The type field uniquely identifies the underlying type of the data field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMetadataEntry {
    pub mType: aiMetadataType,
    pub mData: *mut ::std::os::raw::c_void,
}
impl Default for aiMetadataEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Container for holding metadata.\n\n Metadata is a key-value store using string keys and values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMetadata {
    #[doc = " Length of the mKeys and mValues arrays, respectively"]
    pub mNumProperties: ::std::os::raw::c_uint,
    #[doc = " Arrays of keys, may not be NULL. Entries in this array may not be NULL as well."]
    pub mKeys: *mut aiString,
    #[doc = " Arrays of values, may not be NULL. Entries in this array may be NULL if the\n corresponding property key has no assigned value."]
    pub mValues: *mut aiMetadataEntry,
}
impl Default for aiMetadata {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A node in the imported hierarchy.\n\n Each node has name, a parent node (except for the root node),\n a transformation relative to its parent and possibly several child nodes.\n Simple file formats don't support hierarchical structures - for these formats\n the imported scene does consist of only a single root node without children."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiNode {
    #[doc = " The name of the node.\n\n The name might be empty (length of zero) but all nodes which\n need to be referenced by either bones or animations are named.\n Multiple nodes may have the same name, except for nodes which are referenced\n by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique.\n\n Cameras and lights reference a specific node by name - if there\n are multiple nodes with this name, they are assigned to each of them.\n <br>\n There are no limitations with regard to the characters contained in\n the name string as it is usually taken directly from the source file.\n\n Implementations should be able to handle tokens such as whitespace, tabs,\n line feeds, quotation marks, ampersands etc.\n\n Sometimes assimp introduces new nodes not present in the source file\n into the hierarchy (usually out of necessity because sometimes the\n source hierarchy format is simply not compatible). Their names are\n surrounded by @verbatim <> @endverbatim e.g.\n  @verbatim<DummyRootNode> @endverbatim."]
    pub mName: aiString,
    #[doc = " The transformation relative to the node's parent."]
    pub mTransformation: aiMatrix4x4,
    #[doc = " Parent node. nullptr if this node is the root node."]
    pub mParent: *mut aiNode,
    #[doc = " The number of child nodes of this node."]
    pub mNumChildren: ::std::os::raw::c_uint,
    #[doc = " The child nodes of this node. nullptr if mNumChildren is 0."]
    pub mChildren: *mut *mut aiNode,
    #[doc = " The number of meshes of this node."]
    pub mNumMeshes: ::std::os::raw::c_uint,
    #[doc = " The meshes of this node. Each entry is an index into the\n mesh list of the #aiScene."]
    pub mMeshes: *mut ::std::os::raw::c_uint,
    #[doc = " Metadata associated with this node or nullptr if there is no metadata.\n  Whether any metadata is generated depends on the source file format. See the\n @link importer_notes @endlink page for more information on every source file\n format. Importers that don't document any metadata don't write any."]
    pub mMetaData: *mut aiMetadata,
}
impl Default for aiNode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The root structure of the imported data.\n\n  Everything that was imported from the given file can be accessed from here.\n  Objects of this class are generally maintained and owned by Assimp, not\n  by the caller. You shouldn't want to instance it, nor should you ever try to\n  delete a given scene on your own."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiScene {
    #[doc = " Any combination of the AI_SCENE_FLAGS_XXX flags. By default\n this value is 0, no flags are set. Most applications will\n want to reject all scenes with the AI_SCENE_FLAGS_INCOMPLETE\n bit set."]
    pub mFlags: ::std::os::raw::c_uint,
    #[doc = " The root node of the hierarchy.\n\n There will always be at least the root node if the import\n was successful (and no special flags have been set).\n Presence of further nodes depends on the format and content\n of the imported file."]
    pub mRootNode: *mut aiNode,
    #[doc = " The number of meshes in the scene."]
    pub mNumMeshes: ::std::os::raw::c_uint,
    #[doc = " The array of meshes.\n\n Use the indices given in the aiNode structure to access\n this array. The array is mNumMeshes in size. If the\n AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always\n be at least ONE material."]
    pub mMeshes: *mut *mut aiMesh,
    #[doc = " The number of materials in the scene."]
    pub mNumMaterials: ::std::os::raw::c_uint,
    #[doc = " The array of materials.\n\n Use the index given in each aiMesh structure to access this\n array. The array is mNumMaterials in size. If the\n AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always\n be at least ONE material."]
    pub mMaterials: *mut *mut aiMaterial,
    #[doc = " The number of animations in the scene."]
    pub mNumAnimations: ::std::os::raw::c_uint,
    #[doc = " The array of animations.\n\n All animations imported from the given file are listed here.\n The array is mNumAnimations in size."]
    pub mAnimations: *mut *mut aiAnimation,
    #[doc = " The number of textures embedded into the file"]
    pub mNumTextures: ::std::os::raw::c_uint,
    #[doc = " The array of embedded textures.\n\n Not many file formats embed their textures into the file.\n An example is Quake's MDL format (which is also used by\n some GameStudio versions)"]
    pub mTextures: *mut *mut aiTexture,
    #[doc = " The number of light sources in the scene. Light sources\n are fully optional, in most cases this attribute will be 0"]
    pub mNumLights: ::std::os::raw::c_uint,
    #[doc = " The array of light sources.\n\n All light sources imported from the given file are\n listed here. The array is mNumLights in size."]
    pub mLights: *mut *mut aiLight,
    #[doc = " The number of cameras in the scene. Cameras\n are fully optional, in most cases this attribute will be 0"]
    pub mNumCameras: ::std::os::raw::c_uint,
    #[doc = " The array of cameras.\n\n All cameras imported from the given file are listed here.\n The array is mNumCameras in size. The first camera in the\n array (if existing) is the default camera view into\n the scene."]
    pub mCameras: *mut *mut aiCamera,
    #[doc = "  @brief  The global metadata assigned to the scene itself.\n\n  This data contains global metadata which belongs to the scene like\n  unit-conversions, versions, vendors or other model-specific data. This\n  can be used to store format-specific metadata as well."]
    pub mMetaData: *mut aiMetadata,
    #[doc = " The name of the scene itself."]
    pub mName: aiString,
    pub mNumSkeletons: ::std::os::raw::c_uint,
    pub mSkeletons: *mut *mut aiSkeleton,
    pub mPrivate: *mut ::std::os::raw::c_char,
}
impl Default for aiScene {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod aiPostProcessSteps {
    #[doc = " @enum  aiPostProcessSteps\n  @brief Defines the flags for all possible post processing steps.\n\n  @note Some steps are influenced by properties set on the Assimp::Importer itself\n\n  @see Assimp::Importer::ReadFile()\n  @see Assimp::Importer::SetPropertyInteger()\n  @see aiImportFile\n  @see aiImportFileEx"]
    pub type Type = ::std::os::raw::c_int;
    #[doc = " <hr>Calculates the tangents and bitangents for the imported meshes.\n\n Does nothing if a mesh does not have normals. You might want this post\n processing step to be executed if you plan to use tangent space calculations\n such as normal mapping  applied to the meshes. There's an importer property,\n <tt>#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</tt>, which allows you to specify\n a maximum smoothing angle for the algorithm. However, usually you'll\n want to leave it at the default value."]
    pub const aiProcess_CalcTangentSpace: Type = 1;
    #[doc = " <hr>Identifies and joins identical vertex data sets within all\n  imported meshes.\n\n After this step is run, each mesh contains unique vertices,\n so a vertex may be used by multiple faces. You usually want\n to use this post processing step. If your application deals with\n indexed geometry, this step is compulsory or you'll just waste rendering\n time. <b>If this flag is not specified</b>, no vertices are referenced by\n more than one face and <b>no index buffer is required</b> for rendering.\n Unless the importer (like ply) had to split vertices. Then you need one regardless."]
    pub const aiProcess_JoinIdenticalVertices: Type = 2;
    #[doc = " <hr>Converts all the imported data to a left-handed coordinate space.\n\n By default the data is returned in a right-handed coordinate space (which\n OpenGL prefers). In this space, +X points to the right,\n +Z points towards the viewer, and +Y points upwards. In the DirectX\n coordinate space +X points to the right, +Y points upwards, and +Z points\n away from the viewer.\n\n You'll probably want to consider this flag if you use Direct3D for\n rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this\n setting and bundles all conversions typically required for D3D-based\n applications."]
    pub const aiProcess_MakeLeftHanded: Type = 4;
    #[doc = " <hr>Triangulates all faces of all meshes.\n\n By default the imported mesh data might contain faces with more than 3\n indices. For rendering you'll usually want all faces to be triangles.\n This post processing step splits up faces with more than 3 indices into\n triangles. Line and point primitives are *not* modified! If you want\n 'triangles only' with no other kinds of primitives, try the following\n solution:\n <ul>\n <li>Specify both #aiProcess_Triangulate and #aiProcess_SortByPType </li>\n <li>Ignore all point and line meshes when you process assimp's output</li>\n </ul>"]
    pub const aiProcess_Triangulate: Type = 8;
    #[doc = " <hr>Removes some parts of the data structure (animations, materials,\n  light sources, cameras, textures, vertex components).\n\n The  components to be removed are specified in a separate\n importer property, <tt>#AI_CONFIG_PP_RVC_FLAGS</tt>. This is quite useful\n if you don't need all parts of the output structure. Vertex colors\n are rarely used today for example... Calling this step to remove unneeded\n data from the pipeline as early as possible results in increased\n performance and a more optimized output data structure.\n This step is also useful if you want to force Assimp to recompute\n normals or tangents. The corresponding steps don't recompute them if\n they're already there (loaded from the source asset). By using this\n step you can make sure they are NOT there.\n\n This flag is a poor one, mainly because its purpose is usually\n misunderstood. Consider the following case: a 3D model has been exported\n from a CAD app, and it has per-face vertex colors. Vertex positions can't be\n shared, thus the #aiProcess_JoinIdenticalVertices step fails to\n optimize the data because of these nasty little vertex colors.\n Most apps don't even process them, so it's all for nothing. By using\n this step, unneeded components are excluded as early as possible\n thus opening more room for internal optimizations."]
    pub const aiProcess_RemoveComponent: Type = 16;
    #[doc = " <hr>Generates normals for all faces of all meshes.\n\n This is ignored if normals are already there at the time this flag\n is evaluated. Model importers try to load them from the source file, so\n they're usually already there. Face normals are shared between all points\n of a single face, so a single point can have multiple normals, which\n forces the library to duplicate vertices in some cases.\n #aiProcess_JoinIdenticalVertices is *senseless* then.\n\n This flag may not be specified together with #aiProcess_GenSmoothNormals."]
    pub const aiProcess_GenNormals: Type = 32;
    #[doc = " <hr>Generates smooth normals for all vertices in the mesh.\n\n This is ignored if normals are already there at the time this flag\n is evaluated. Model importers try to load them from the source file, so\n they're usually already there.\n\n This flag may not be specified together with\n #aiProcess_GenNormals. There's a importer property,\n <tt>#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</tt> which allows you to specify\n an angle maximum for the normal smoothing algorithm. Normals exceeding\n this limit are not smoothed, resulting in a 'hard' seam between two faces.\n Using a decent angle here (e.g. 80 degrees) results in very good visual\n appearance."]
    pub const aiProcess_GenSmoothNormals: Type = 64;
    #[doc = " <hr>Splits large meshes into smaller sub-meshes.\n\n This is quite useful for real-time rendering, where the number of triangles\n which can be maximally processed in a single draw-call is limited\n by the video driver/hardware. The maximum vertex buffer is usually limited\n too. Both requirements can be met with this step: you may specify both a\n triangle and vertex limit for a single mesh.\n\n The split limits can (and should!) be set through the\n <tt>#AI_CONFIG_PP_SLM_VERTEX_LIMIT</tt> and <tt>#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</tt>\n importer properties. The default values are <tt>#AI_SLM_DEFAULT_MAX_VERTICES</tt> and\n <tt>#AI_SLM_DEFAULT_MAX_TRIANGLES</tt>.\n\n Note that splitting is generally a time-consuming task, but only if there's\n something to split. The use of this step is recommended for most users."]
    pub const aiProcess_SplitLargeMeshes: Type = 128;
    #[doc = " <hr>Removes the node graph and pre-transforms all vertices with\n the local transformation matrices of their nodes.\n\n If the resulting scene can be reduced to a single mesh, with a single\n material, no lights, and no cameras, then the output scene will contain\n only a root node (with no children) that references the single mesh.\n Otherwise, the output scene will be reduced to a root node with a single\n level of child nodes, each one referencing one mesh, and each mesh\n referencing one material.\n\n In either case, for rendering, you can\n simply render all meshes in order - you don't need to pay\n attention to local transformations and the node hierarchy.\n Animations are removed during this step.\n This step is intended for applications without a scenegraph.\n The step CAN cause some problems: if e.g. a mesh of the asset\n contains normals and another, using the same material index, does not,\n they will be brought together, but the first meshes's part of\n the normal list is zeroed. However, these artifacts are rare.\n @note The <tt>#AI_CONFIG_PP_PTV_NORMALIZE</tt> configuration property\n can be set to normalize the scene's spatial dimension to the -1...1\n range."]
    pub const aiProcess_PreTransformVertices: Type = 256;
    #[doc = " <hr>Limits the number of bones simultaneously affecting a single vertex\n  to a maximum value.\n\n If any vertex is affected by more than the maximum number of bones, the least\n important vertex weights are removed and the remaining vertex weights are\n renormalized so that the weights still sum up to 1.\n The default bone weight limit is 4 (defined as <tt>#AI_LMW_MAX_WEIGHTS</tt> in\n config.h), but you can use the <tt>#AI_CONFIG_PP_LBW_MAX_WEIGHTS</tt> importer\n property to supply your own limit to the post processing step.\n\n If you intend to perform the skinning in hardware, this post processing\n step might be of interest to you."]
    pub const aiProcess_LimitBoneWeights: Type = 512;
    #[doc = " <hr>Validates the imported scene data structure.\n This makes sure that all indices are valid, all animations and\n bones are linked correctly, all material references are correct .. etc.\n\n It is recommended that you capture Assimp's log output if you use this flag,\n so you can easily find out what's wrong if a file fails the\n validation. The validator is quite strict and will find *all*\n inconsistencies in the data structure... It is recommended that plugin\n developers use it to debug their loaders. There are two types of\n validation failures:\n <ul>\n <li>Error: There's something wrong with the imported data. Further\n   postprocessing is not possible and the data is not usable at all.\n   The import fails. #Importer::GetErrorString() or #aiGetErrorString()\n   carry the error message around.</li>\n <li>Warning: There are some minor issues (e.g. 1000000 animation\n   keyframes with the same time), but further postprocessing and use\n   of the data structure is still safe. Warning details are written\n   to the log file, <tt>#AI_SCENE_FLAGS_VALIDATION_WARNING</tt> is set\n   in #aiScene::mFlags</li>\n </ul>\n\n This post-processing step is not time-consuming. Its use is not\n compulsory, but recommended."]
    pub const aiProcess_ValidateDataStructure: Type = 1024;
    #[doc = " <hr>Reorders triangles for better vertex cache locality.\n\n The step tries to improve the ACMR (average post-transform vertex cache\n miss ratio) for all meshes. The implementation runs in O(n) and is\n roughly based on the 'tipsify' algorithm (see <a href=\"\n http://www.cs.princeton.edu/gfx/pubs/Sander_2007_%3ETR/tipsy.pdf\">this\n paper</a>).\n\n If you intend to render huge models in hardware, this step might\n be of interest to you. The <tt>#AI_CONFIG_PP_ICL_PTCACHE_SIZE</tt>\n importer property can be used to fine-tune the cache optimization."]
    pub const aiProcess_ImproveCacheLocality: Type = 2048;
    #[doc = " <hr>Searches for redundant/unreferenced materials and removes them.\n\n This is especially useful in combination with the\n #aiProcess_PreTransformVertices and #aiProcess_OptimizeMeshes flags.\n Both join small meshes with equal characteristics, but they can't do\n their work if two meshes have different materials. Because several\n material settings are lost during Assimp's import filters,\n (and because many exporters don't check for redundant materials), huge\n models often have materials which are are defined several times with\n exactly the same settings.\n\n Several material settings not contributing to the final appearance of\n a surface are ignored in all comparisons (e.g. the material name).\n So, if you're passing additional information through the\n content pipeline (probably using *magic* material names), don't\n specify this flag. Alternatively take a look at the\n <tt>#AI_CONFIG_PP_RRM_EXCLUDE_LIST</tt> importer property."]
    pub const aiProcess_RemoveRedundantMaterials: Type = 4096;
    #[doc = " <hr>This step tries to determine which meshes have normal vectors\n that are facing inwards and inverts them.\n\n The algorithm is simple but effective:\n the bounding box of all vertices + their normals is compared against\n the volume of the bounding box of all vertices without their normals.\n This works well for most objects, problems might occur with planar\n surfaces. However, the step tries to filter such cases.\n The step inverts all in-facing normals. Generally it is recommended\n to enable this step, although the result is not always correct."]
    pub const aiProcess_FixInfacingNormals: Type = 8192;
    #[doc = " This step generically populates aiBone->mArmature and aiBone->mNode generically\n The point of these is it saves you later having to calculate these elements\n This is useful when handling rest information or skin information\n If you have multiple armatures on your models we strongly recommend enabling this\n Instead of writing your own multi-root, multi-armature lookups we have done the\n hard work for you :)"]
    pub const aiProcess_PopulateArmatureData: Type = 16384;
    #[doc = " <hr>This step splits meshes with more than one primitive type in\n  homogeneous sub-meshes.\n\n  The step is executed after the triangulation step. After the step\n  returns, just one bit is set in aiMesh::mPrimitiveTypes. This is\n  especially useful for real-time rendering where point and line\n  primitives are often ignored or rendered separately.\n  You can use the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to\n  specify which primitive types you need. This can be used to easily\n  exclude lines and points, which are rarely used, from the import."]
    pub const aiProcess_SortByPType: Type = 32768;
    #[doc = " <hr>This step searches all meshes for degenerate primitives and\n  converts them to proper lines or points.\n\n A face is 'degenerate' if one or more of its points are identical.\n To have the degenerate stuff not only detected and collapsed but\n removed, try one of the following procedures:\n <br><b>1.</b> (if you support lines and points for rendering but don't\n    want the degenerates)<br>\n <ul>\n   <li>Specify the #aiProcess_FindDegenerates flag.\n   </li>\n   <li>Set the <tt>#AI_CONFIG_PP_FD_REMOVE</tt> importer property to\n       1. This will cause the step to remove degenerate triangles from the\n       import as soon as they're detected. They won't pass any further\n       pipeline steps.\n   </li>\n </ul>\n <br><b>2.</b>(if you don't support lines and points at all)<br>\n <ul>\n   <li>Specify the #aiProcess_FindDegenerates flag.\n   </li>\n   <li>Specify the #aiProcess_SortByPType flag. This moves line and\n     point primitives to separate meshes.\n   </li>\n   <li>Set the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to\n       @code aiPrimitiveType_POINT | aiPrimitiveType_LINE\n       @endcode to cause SortByPType to reject point\n       and line meshes from the scene.\n   </li>\n </ul>\n\n This step also removes very small triangles with a surface area smaller\n than 10^-6. If you rely on having these small triangles, or notice holes\n in your model, set the property <tt>#AI_CONFIG_PP_FD_CHECKAREA</tt> to\n false.\n @note Degenerate polygons are not necessarily evil and that's why\n they're not removed by default. There are several file formats which\n don't support lines or points, and some exporters bypass the\n format specification and write them as degenerate triangles instead."]
    pub const aiProcess_FindDegenerates: Type = 65536;
    #[doc = " <hr>This step searches all meshes for invalid data, such as zeroed\n  normal vectors or invalid UV coords and removes/fixes them. This is\n  intended to get rid of some common exporter errors.\n\n This is especially useful for normals. If they are invalid, and\n the step recognizes this, they will be removed and can later\n be recomputed, i.e. by the #aiProcess_GenSmoothNormals flag.<br>\n The step will also remove meshes that are infinitely small and reduce\n animation tracks consisting of hundreds if redundant keys to a single\n key. The <tt>AI_CONFIG_PP_FID_ANIM_ACCURACY</tt> config property decides\n the accuracy of the check for duplicate animation tracks."]
    pub const aiProcess_FindInvalidData: Type = 131072;
    #[doc = " <hr>This step converts non-UV mappings (such as spherical or\n  cylindrical mapping) to proper texture coordinate channels.\n\n Most applications will support UV mapping only, so you will\n probably want to specify this step in every case. Note that Assimp is not\n always able to match the original mapping implementation of the\n 3D app which produced a model perfectly. It's always better to let the\n modelling app compute the UV channels - 3ds max, Maya, Blender,\n LightWave, and Modo do this for example.\n\n @note If this step is not requested, you'll need to process the\n <tt>#AI_MATKEY_MAPPING</tt> material property in order to display all assets\n properly."]
    pub const aiProcess_GenUVCoords: Type = 262144;
    #[doc = " <hr>This step applies per-texture UV transformations and bakes\n  them into stand-alone vtexture coordinate channels.\n\n UV transformations are specified per-texture - see the\n <tt>#AI_MATKEY_UVTRANSFORM</tt> material key for more information.\n This step processes all textures with\n transformed input UV coordinates and generates a new (pre-transformed) UV channel\n which replaces the old channel. Most applications won't support UV\n transformations, so you will probably want to specify this step.\n\n @note UV transformations are usually implemented in real-time apps by\n transforming texture coordinates at vertex shader stage with a 3x3\n (homogeneous) transformation matrix."]
    pub const aiProcess_TransformUVCoords: Type = 524288;
    #[doc = " <hr>This step searches for duplicate meshes and replaces them\n  with references to the first mesh.\n\n  This step takes a while, so don't use it if speed is a concern.\n  Its main purpose is to workaround the fact that many export\n  file formats don't support instanced meshes, so exporters need to\n  duplicate meshes. This step removes the duplicates again. Please\n  note that Assimp does not currently support per-node material\n  assignment to meshes, which means that identical meshes with\n  different materials are currently *not* joined, although this is\n  planned for future versions."]
    pub const aiProcess_FindInstances: Type = 1048576;
    #[doc = " <hr>A post-processing step to reduce the number of meshes.\n\n  This will, in fact, reduce the number of draw calls.\n\n  This is a very effective optimization and is recommended to be used\n  together with #aiProcess_OptimizeGraph, if possible. The flag is fully\n  compatible with both #aiProcess_SplitLargeMeshes and #aiProcess_SortByPType."]
    pub const aiProcess_OptimizeMeshes: Type = 2097152;
    #[doc = " <hr>A post-processing step to optimize the scene hierarchy.\n\n  Nodes without animations, bones, lights or cameras assigned are\n  collapsed and joined.\n\n  Node names can be lost during this step. If you use special 'tag nodes'\n  to pass additional information through your content pipeline, use the\n  <tt>#AI_CONFIG_PP_OG_EXCLUDE_LIST</tt> importer property to specify a\n  list of node names you want to be kept. Nodes matching one of the names\n  in this list won't be touched or modified.\n\n  Use this flag with caution. Most simple files will be collapsed to a\n  single node, so complex hierarchies are usually completely lost. This is not\n  useful for editor environments, but probably a very effective\n  optimization if you just want to get the model data, convert it to your\n  own format, and render it as fast as possible.\n\n  This flag is designed to be used with #aiProcess_OptimizeMeshes for best\n  results.\n\n  @note 'Crappy' scenes with thousands of extremely small meshes packed\n  in deeply nested nodes exist for almost all file formats.\n  #aiProcess_OptimizeMeshes in combination with #aiProcess_OptimizeGraph\n  usually fixes them all and makes them renderable."]
    pub const aiProcess_OptimizeGraph: Type = 4194304;
    #[doc = " <hr>This step flips all UV coordinates along the y-axis and adjusts\n material settings and bitangents accordingly.\n\n <b>Output UV coordinate system:</b>\n @code\n 0x|0y ---------- 1x|0y\n |                 |\n |                 |\n |                 |\n 0x|1y ---------- 1x|1y\n @endcode\n\n You'll probably want to consider this flag if you use Direct3D for\n rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this\n setting and bundles all conversions typically required for D3D-based\n applications."]
    pub const aiProcess_FlipUVs: Type = 8388608;
    #[doc = " <hr>This step adjusts the output face winding order to be CW.\n\n The default face winding order is counter clockwise (CCW).\n\n <b>Output face order:</b>\n @code\n       x2\n\n                         x0\n  x1\n @endcode"]
    pub const aiProcess_FlipWindingOrder: Type = 16777216;
    #[doc = " <hr>This step splits meshes with many bones into sub-meshes so that each\n sub-mesh has fewer or as many bones as a given limit."]
    pub const aiProcess_SplitByBoneCount: Type = 33554432;
    #[doc = " <hr>This step removes bones losslessly or according to some threshold.\n\n  In some cases (i.e. formats that require it) exporters are forced to\n  assign dummy bone weights to otherwise static meshes assigned to\n  animated meshes. Full, weight-based skinning is expensive while\n  animating nodes is extremely cheap, so this step is offered to clean up\n  the data in that regard.\n\n  Use <tt>#AI_CONFIG_PP_DB_THRESHOLD</tt> to control this.\n  Use <tt>#AI_CONFIG_PP_DB_ALL_OR_NONE</tt> if you want bones removed if and\n  only if all bones within the scene qualify for removal."]
    pub const aiProcess_Debone: Type = 67108864;
    #[doc = " <hr>This step will perform a global scale of the model.\n\n  Some importers are providing a mechanism to define a scaling unit for the\n  model. This post processing step can be used to do so. You need to get the\n  global scaling from your importer settings like in FBX. Use the flag\n  AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY from the global property table to configure this.\n\n  Use <tt>#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</tt> to setup the global scaling factor."]
    pub const aiProcess_GlobalScale: Type = 134217728;
    #[doc = " <hr>A postprocessing step to embed of textures.\n\n  This will remove external data dependencies for textures.\n  If a texture's file does not exist at the specified path\n  (due, for instance, to an absolute path generated on another system),\n  it will check if a file with the same name exists at the root folder\n  of the imported model. And if so, it uses that."]
    pub const aiProcess_EmbedTextures: Type = 268435456;
    #[doc = " <hr>A postprocessing step to embed of textures.\n\n  This will remove external data dependencies for textures.\n  If a texture's file does not exist at the specified path\n  (due, for instance, to an absolute path generated on another system),\n  it will check if a file with the same name exists at the root folder\n  of the imported model. And if so, it uses that."]
    pub const aiProcess_ForceGenNormals: Type = 536870912;
    #[doc = " <hr>Drops normals for all faces of all meshes.\n\n This is ignored if no normals are present.\n Face normals are shared between all points of a single face,\n so a single point can have multiple normals, which\n forces the library to duplicate vertices in some cases.\n #aiProcess_JoinIdenticalVertices is *senseless* then.\n This process gives sense back to aiProcess_JoinIdenticalVertices"]
    pub const aiProcess_DropNormals: Type = 1073741824;
    pub const aiProcess_GenBoundingBoxes: Type = -2147483648;
}
#[doc = "  @brief  Describes an file format which Assimp can export to.\n\n  Use #aiGetExportFormatCount() to learn how many export-formats are supported by\n  the current Assimp-build and #aiGetExportFormatDescription() to retrieve the\n  description of the export format option."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiExportFormatDesc {
    #[doc = " a short string ID to uniquely identify the export format. Use this ID string to\n specify which file format you want to export to when calling #aiExportScene().\n Example: \"dae\" or \"obj\""]
    pub id: *const ::std::os::raw::c_char,
    #[doc = " A short description of the file format to present to users. Useful if you want\n to allow the user to select an export format."]
    pub description: *const ::std::os::raw::c_char,
    #[doc = " Recommended file extension for the exported file in lower case."]
    pub fileExtension: *const ::std::os::raw::c_char,
}
impl Default for aiExportFormatDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Returns the number of export file formats available in the current Assimp build.\n Use aiGetExportFormatDescription() to retrieve infos of a specific export format."]
    pub fn aiGetExportFormatCount() -> usize;
}
unsafe extern "C" {
    #[doc = " Returns a description of the nth export file format. Use #aiGetExportFormatCount()\n to learn how many export formats are supported. The description must be released by\n calling aiReleaseExportFormatDescription afterwards.\n @param pIndex Index of the export format to retrieve information for. Valid range is\n    0 to #aiGetExportFormatCount()\n @return A description of that specific export format. NULL if pIndex is out of range."]
    pub fn aiGetExportFormatDescription(pIndex: usize) -> *const aiExportFormatDesc;
}
unsafe extern "C" {
    #[doc = " Release a description of the nth export file format. Must be returned by\n aiGetExportFormatDescription\n @param desc Pointer to the description"]
    pub fn aiReleaseExportFormatDescription(desc: *const aiExportFormatDesc);
}
unsafe extern "C" {
    #[doc = " Create a modifiable copy of a scene.\n  This is useful to import files via Assimp, change their topology and\n  export them again. Since the scene returned by the various importer functions\n  is const, a modifiable copy is needed.\n  @param pIn Valid scene to be copied\n  @param pOut Receives a modifiable copy of the scene. Use aiFreeScene() to\n    delete it again."]
    pub fn aiCopyScene(pIn: *const aiScene, pOut: *mut *mut aiScene);
}
unsafe extern "C" {
    #[doc = " Frees a scene copy created using aiCopyScene()"]
    pub fn aiFreeScene(pIn: *const aiScene);
}
unsafe extern "C" {
    #[doc = " Exports the given scene to a chosen file format and writes the result file(s) to disk.\n @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.\n   The scene is expected to conform to Assimp's Importer output format as specified\n   in the @link data Data Structures Page @endlink. In short, this means the model data\n   should use a right-handed coordinate systems, face winding should be counter-clockwise\n   and the UV coordinate origin is assumed to be in the upper left. If your input data\n   uses different conventions, have a look at the last parameter.\n @param pFormatId ID string to specify to which format you want to export to. Use\n aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.\n @param pFileName Output file to write\n @param pPreprocessing Accepts any choice of the #aiPostProcessSteps enumerated\n   flags, but in reality only a subset of them makes sense here. Specifying\n   'preprocessing' flags is useful if the input scene does not conform to\n   Assimp's default conventions as specified in the @link data Data Structures Page @endlink.\n   In short, this means the geometry data should use a right-handed coordinate systems, face\n   winding should be counter-clockwise and the UV coordinate origin is assumed to be in\n   the upper left. The #aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and\n   #aiProcess_FlipWindingOrder flags are used in the import side to allow users\n   to have those defaults automatically adapted to their conventions. Specifying those flags\n   for exporting has the opposite effect, respectively. Some other of the\n   #aiPostProcessSteps enumerated values may be useful as well, but you'll need\n   to try out what their effect on the exported file is. Many formats impose\n   their own restrictions on the structure of the geometry stored therein,\n   so some preprocessing may have little or no effect at all, or may be\n   redundant as exporters would apply them anyhow. A good example\n   is triangulation - whilst you can enforce it by specifying\n   the #aiProcess_Triangulate flag, most export formats support only\n   triangulate data so they would run the step anyway.\n\n   If assimp detects that the input scene was directly taken from the importer side of\n   the library (i.e. not copied using aiCopyScene and potentially modified afterwards),\n   any post-processing steps already applied to the scene will not be applied again, unless\n   they show non-idempotent behavior (#aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and\n   #aiProcess_FlipWindingOrder).\n @return a status code indicating the result of the export\n @note Use aiCopyScene() to get a modifiable copy of a previously\n   imported scene."]
    pub fn aiExportScene(
        pScene: *const aiScene,
        pFormatId: *const ::std::os::raw::c_char,
        pFileName: *const ::std::os::raw::c_char,
        pPreprocessing: ::std::os::raw::c_uint,
    ) -> aiReturn;
}
unsafe extern "C" {
    #[doc = " Exports the given scene to a chosen file format using custom IO logic supplied by you.\n @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.\n @param pFormatId ID string to specify to which format you want to export to. Use\n aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.\n @param pFileName Output file to write\n @param pIO custom IO implementation to be used. Use this if you use your own storage methods.\n   If none is supplied, a default implementation using standard file IO is used. Note that\n   #aiExportSceneToBlob is provided as convenience function to export to memory buffers.\n @param pPreprocessing Please see the documentation for #aiExportScene\n @return a status code indicating the result of the export\n @note Include <aiFileIO.h> for the definition of #aiFileIO.\n @note Use aiCopyScene() to get a modifiable copy of a previously\n   imported scene."]
    pub fn aiExportSceneEx(
        pScene: *const aiScene,
        pFormatId: *const ::std::os::raw::c_char,
        pFileName: *const ::std::os::raw::c_char,
        pIO: *mut aiFileIO,
        pPreprocessing: ::std::os::raw::c_uint,
    ) -> aiReturn;
}
#[doc = " Describes a blob of exported scene data. Use #aiExportSceneToBlob() to create a blob containing an\n exported scene. The memory referred by this structure is owned by Assimp.\n to free its resources. Don't try to free the memory on your side - it will crash for most build configurations\n due to conflicting heaps.\n\n Blobs can be nested - each blob may reference another blob, which may in turn reference another blob and so on.\n This is used when exporters write more than one output file for a given #aiScene. See the remarks for\n #aiExportDataBlob::name for more information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiExportDataBlob {
    #[doc = " Size of the data in bytes"]
    pub size: usize,
    #[doc = " The data."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Name of the blob. An empty string always\n indicates the first (and primary) blob,\n which contains the actual file data.\n Any other blobs are auxiliary files produced\n by exporters (i.e. material files). Existence\n of such files depends on the file format. Most\n formats don't split assets across multiple files.\n\n If used, blob names usually contain the file\n extension that should be used when writing\n the data to disc.\n\n The blob names generated can be influenced by\n setting the #AI_CONFIG_EXPORT_BLOB_NAME export\n property to the name that is used for the master\n blob. All other names are typically derived from\n the base name, by the file format exporter."]
    pub name: aiString,
    #[doc = " Pointer to the next blob in the chain or NULL if there is none."]
    pub next: *mut aiExportDataBlob,
}
impl Default for aiExportDataBlob {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Exports the given scene to a chosen file format. Returns the exported data as a binary blob which\n you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()\n to free the resources associated with the export.\n @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.\n @param pFormatId ID string to specify to which format you want to export to. Use\n #aiGetExportFormatCount() / #aiGetExportFormatDescription() to learn which export formats are available.\n @param pPreprocessing Please see the documentation for #aiExportScene\n @return the exported data or NULL in case of error"]
    pub fn aiExportSceneToBlob(
        pScene: *const aiScene,
        pFormatId: *const ::std::os::raw::c_char,
        pPreprocessing: ::std::os::raw::c_uint,
    ) -> *const aiExportDataBlob;
}
unsafe extern "C" {
    #[doc = " Releases the memory associated with the given exported data. Use this function to free a data blob\n returned by aiExportScene().\n @param pData the data blob returned by #aiExportSceneToBlob"]
    pub fn aiReleaseExportBlob(pData: *const aiExportDataBlob);
}
pub type aiFileWriteProc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut aiFile,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: usize,
    ) -> usize,
>;
pub type aiFileReadProc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut aiFile,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: usize,
    ) -> usize,
>;
pub type aiFileTellProc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut aiFile) -> usize>;
pub type aiFileFlushProc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut aiFile)>;
pub type aiFileSeek = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut aiFile, arg2: usize, arg3: aiOrigin) -> aiReturn,
>;
pub type aiFileOpenProc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut aiFileIO,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut aiFile,
>;
pub type aiFileCloseProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut aiFileIO, arg2: *mut aiFile)>;
pub type aiUserData = *mut ::std::os::raw::c_char;
#[doc = " @brief C-API: File system callbacks\n\n  Provided are functions to open and close files. Supply a custom structure to\n  the import function. If you don't, a default implementation is used. Use custom\n  file systems to enable reading from other sources, such as ZIPs\n  or memory locations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiFileIO {
    #[doc = " Function used to open a new file"]
    pub OpenProc: aiFileOpenProc,
    #[doc = " Function used to close an existing file"]
    pub CloseProc: aiFileCloseProc,
    #[doc = " User-defined, opaque data"]
    pub UserData: aiUserData,
}
impl Default for aiFileIO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief C-API: File callbacks\n\n  Actually, it's a data structure to wrap a set of fXXXX (e.g fopen)\n  replacement functions.\n\n  The default implementation of the functions utilizes the fXXX functions from\n  the CRT. However, you can supply a custom implementation to Assimp by\n  delivering a custom aiFileIO. Use this to enable reading from other sources,\n  such as ZIP archives or memory locations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiFile {
    #[doc = " Callback to read from a file"]
    pub ReadProc: aiFileReadProc,
    #[doc = " Callback to write to a file"]
    pub WriteProc: aiFileWriteProc,
    #[doc = " Callback to retrieve the current position of\n  the file cursor (ftell())"]
    pub TellProc: aiFileTellProc,
    #[doc = " Callback to retrieve the size of the file,\n  in bytes"]
    pub FileSizeProc: aiFileTellProc,
    #[doc = " Callback to set the current position\n of the file cursor (fseek())"]
    pub SeekProc: aiFileSeek,
    #[doc = " Callback to flush the file contents"]
    pub FlushProc: aiFileFlushProc,
    #[doc = " User-defined, opaque data"]
    pub UserData: aiUserData,
}
impl Default for aiFile {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " @brief Returns a string with legal copyright and licensing information\n  about Assimp. The string may include multiple lines.\n  @return Pointer to static string."]
    pub fn aiGetLegalString() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Returns the current patch version number of Assimp.\n  @return Patch version of the Assimp runtime the application was\n    linked/built against"]
    pub fn aiGetVersionPatch() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " @brief Returns the current minor version number of Assimp.\n  @return Minor version of the Assimp runtime the application was\n    linked/built against"]
    pub fn aiGetVersionMinor() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " @brief Returns the current major version number of Assimp.\n  @return Major version of the Assimp runtime the application was\n    linked/built against"]
    pub fn aiGetVersionMajor() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " @brief Returns the repository revision of the Assimp runtime.\n  @return SVN Repository revision number of the Assimp runtime the\n          application was linked/built against."]
    pub fn aiGetVersionRevision() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " @brief Returns the branch-name of the Assimp runtime.\n  @return The current branch name."]
    pub fn aiGetBranchName() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Returns assimp's compile flags\n  @return Any bitwise combination of the ASSIMP_CFLAGS_xxx constants."]
    pub fn aiGetCompileFlags() -> ::std::os::raw::c_uint;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aiRustPropertyKind {
    aiRustPropertyKind_Integer = 0,
    aiRustPropertyKind_Float = 1,
    aiRustPropertyKind_String = 2,
    aiRustPropertyKind_Matrix4x4 = 3,
    aiRustPropertyKind_Boolean = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiRustProperty {
    pub name: *const ::std::os::raw::c_char,
    pub kind: aiRustPropertyKind,
    pub int_value: ::std::os::raw::c_int,
    pub float_value: f32,
    pub string_value: *const ::std::os::raw::c_char,
    pub matrix_value: *mut ::std::os::raw::c_void,
}
impl Default for aiRustProperty {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aiRustProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        percentage: f32,
        message: *const ::std::os::raw::c_char,
        user: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    pub fn aiImportFileExWithProgressRust(
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        file_io: *const aiFileIO,
        props: *const aiRustProperty,
        props_count: usize,
        progress_cb: aiRustProgressCallback,
        progress_user: *mut ::std::os::raw::c_void,
    ) -> *const aiScene;
}
unsafe extern "C" {
    pub fn aiImportFileFromMemoryWithProgressRust(
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        hint: *const ::std::os::raw::c_char,
        props: *const aiRustProperty,
        props_count: usize,
        progress_cb: aiRustProgressCallback,
        progress_user: *mut ::std::os::raw::c_void,
    ) -> *const aiScene;
}
unsafe extern "C" {
    pub fn aiGetLastErrorStringRust() -> *const ::std::os::raw::c_char;
}
